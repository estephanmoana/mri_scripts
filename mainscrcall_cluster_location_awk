#! /bin/bash

# This script will lookup the results from FEAT analysis and provide their location according to the atlases available in FSL

# Sourcing of functions library files #
. mainscrcall_funclib

# Setting Ctrl + C as key combination to go back to PROCESSING menu. Also signals to the log file (=if there is one) that this script was interrupted
trap "echo -en '\n\nGoing back to the PROCESSING menu '; sleep 2; log_file_scripts_used interrupt; exit" SIGINT

# Checking if variables are not empty
emptvar=${MEDIA}
var_checked="THE MAIN FOLDER HOLDING MRI DATA"
checkemptvar

emptvar=${EXPERIMENT}
var_checked="THE EXPERIMENT NAME"
checkemptvar

# emptvar="${SUBJLIST}"
# var_checked="THE SUBJECT(S) TO BE PROCESSED"
# checkemptvar
#
# emptvar="${SUBJS_FOLDERS_PATH}"
# var_checked="THE FOLDER CONTAINING ALL SUBJECTS' FOLDERS"
# checkemptvar


##########			FUNCTIONS USED IN THIS SCRIPT			##########

function rawdata_feat {
# This function will allow the user to select the feat folders with the files to be processed
clear

##### VARIABLES TO BE USED IN THIS FUNCTION AND SUBSEQUENT ONES #####
# Variable holding what analysis level to be processed
analysis_level=$1

# Variable to hold the folder where the scripts results will be saved
script_results_folder=$2 # Used only in the function "extract_results"

# OUTPUT directory defined here
OUTDIR="${FULLPATH}/${analysis_level}/${script_results_folder}" # Used only in the function "extract_results"
#####################################################################

echo
echo -e "Processing higher-level FEAT analysis results\n"

while [ 1 ]
do
	# Retrieving the subjects with results within the "/analysis/2nd_level" folder
	echo -e "\n"
	echo -e "These are the folders inside \"${FULLPATH}/${analysis_level}\":\n"

	# Notice the use of single quotes around the variables so it can be parsed correctly
	ls -d ${FULLPATH}/${analysis_level}/*.gfeat | sed 's!'${FULLPATH}/${analysis_level}/'!!' | sed 's!.gfeat!!' | sed "=" | sed 'N; s/\n/) /'

	echo
	echo -en "\tPlease enter here the number corresponding to the subjects/group to have their results processed (if more than one, separate with a space; if you want ALL of them, just enter \"all\"): "
	read SUBJLIST_local

	echo
	echo -e "\nSubjects/group entered: "

	echo

	if [ "$SUBJLIST_local" = all ] || [ "$SUBJLIST_local" = ALL ]
	then
		# Variable to assign subjects list to "all"
		subjects_all=yes

		SUBJLIST_local="`ls -d ${FULLPATH}/${analysis_level}/*.gfeat | sed 's!'${FULLPATH}/${analysis_level}/'!!' | sed 's/.gfeat//'`"

		# Establishing tne initial subject numbering
		subjnumber=1

		for subj in ${SUBJLIST_local}
		do
			echo "${subjnumber}) ${subj}"

			# adding a unit to the numbering variable
			subjnumber=$[ $subjnumber + 1 ]
		done
	else
		# Variable to assign subjects list to "all"
		subjects_all=no

		# Collecting the anatomical files available into a variable to be used in the FUNCTION "NUMBERED_LIST" (functionslibr_FSL)
		var1_available=`ls -d ${FULLPATH}/${analysis_level}/*.gfeat | sed 's!'${FULLPATH}/${analysis_level}/'!!' | sed 's/.gfeat//' | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list
		var2_list="${SUBJLIST_local}" # The numbers chosen by the user corresponding to the files to be used

		# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
		numbered_list_display "${var1_available}" "${var2_list}"

		# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
		SUBJLIST_local=`echo ${files_to_use}`

		# Cleaning the contents of the variables below
		unset files_to_use

		for subj in ${SUBJLIST_local}
		do
			echo ${subj}
		done
	fi

	echo
	echo -en "Is this correct? (y/n) "
	read conf

	# Check if the functional runs entered are correct
	if [ ${conf} = y ]
	then
		echo -e "\n"
		echo -e "\tResults for these subjects/group will be be used: \"${SUBJLIST_local}\"\n"

		for SUBJ in ${SUBJLIST_local}
		do
			# Listing all functional runs for this subject
			echo -e "\n"
			echo -e "\tFind below the clusters listing for subject/group \"${SUBJ}\"\n"

			# Entering the subject-level results folder for this subject
			cd ${FULLPATH}/${analysis_level}/${SUBJ}.gfeat/cope1.feat

			# This will retrieve the names of real contrasts of the design.fsf file of the higher-level analyzes
			echo -e "\tThese are the contrasts used for this analysis\n"
			echo -e "\tTheir numbering is equivalent to the zstats files below, i.e., \"constrast 1\" results are reported in \"cluster_zstat1_std.txt\"\n"

			#### PROCESSING FILE containing the CONTRAST names #####
			# Creating a file holding the contrasts names (copes)
			cat design.fsf | sed -n 's!set fmri(conname_real.!zstat!p' | sed 's!)!!g' | sed 's!"!!g' | sed 's! !_!g' | tee ${temp_folder}/${SUBJ}_COPE_NAMES.txt

			# Collecting the list of cluster_zstatX_std.txt files for the subject (clusters of max activation) - we use the std files because these have coordinates in standard space
			echo
			echo -e "\tThese are the clusters results files for subject/group \"${SUBJ}\":\n`ls -1 cluster_zstat?_std.txt; ls -1 cluster_zstat??_std.txt 2> /dev/null`\n"

			#### PROCESSING FILE containing the CLUSTER information #####
			# Storing the CLUSTER_LIST variable content in a text file. Note the use of "?" and "??" to sort files with diferent number of digits in the name
			ls cluster_zstat?_std.txt > ${temp_folder}/${SUBJ}_CLUSTER_LIST.txt
			ls cluster_zstat??_std.txt >> ${temp_folder}/${SUBJ}_CLUSTER_LIST.txt 2> /dev/null ## Redirecting any error from this command in case a subject does not have a zstat file with 2 digits

			# Collecting the list of lmax_zstatX_std.txt files for the subject (local maxima) - we use the std files because these have coordinates in standard space
			echo -e "\tThese are the local maxima results files for subject/group \"${SUBJ}:\n`ls -1 lmax_zstat?_std.txt; ls -1 lmax_zstat??_std.txt 2> /dev/null`\n"

			#### PROCESSING FILE containing the LOCAL MAXIMA information #####
			# Storing the LOCALMAX_LIST variable content in a text file. Note the use of "?" and "??" to sort files with diferent number of digits in the name
			ls lmax_zstat?_std.txt > ${temp_folder}/${SUBJ}_LOCALMAX_LIST.txt
			ls lmax_zstat??_std.txt >> ${temp_folder}/${SUBJ}_LOCALMAX_LIST.txt 2> /dev/null ## Redirecting any error from this command in case a subject does not have a zstat file with 2 digits
		done

		# Getting out of the while [ 1 ] loop
		break
	else
		echo -e "\n"
		echo -en "Please correct the subjects/group entered "
		sleep 2
	fi
done
}

function rawdata_otherFSLtools {
# This function will allow the user to select the folders with the files to be processed
clear

# Giving feedback to the user
echo
echo -e "*** Processing other FSL tools analysis results ***"

echo -e "Here you can extract information from other analysis beyond those from FEAT, e.g., output from FSL-VBM analisis using randomise"
echo -e "First, you need to have processed the output images using the FSL tool \"cluster\", generating 2 text files:"
echo -e "\t1. \"cluster\" main output: the table reporting the different clusters, their size, and information about their location (in mm coordinates (using option \"--mm\") for atlasquery proper function, not voxels mm) and contents"
echo -e "\t2. Local maxima output: generated by using the option \"--olmax\""
echo -e "You must also have the \"design.con\" file from the FSL tool \"Glm\" used for the analysis"

echo
echo -e "All these files must be inside a single folder"

# Loop for user input
while [ 1 ]
do
	echo -e "\n"
	echo -en "Enter here the FULLPATH for the folder with all the above files: "
	read folder_processing_user

	echo
	echo -en "Please enter a name for the type of analysis done, e.g., \"fslvbm\": "
	read analysis_name_user

	# Checking the contents of the folder indicated by the user
	echo -e "\n"
	echo -e "This is the content of the folder above:"

	echo
	# Notice the use of single quotes around the variables so it can be parsed correctly
	ls -d ${folder_processing_user}/* | awk -F/ '{print $NF}' | sed "=" | sed 'N; s/\n/) /'

	echo
	echo -e "analysis name entered = ${analysis_name_user}"

	echo
	echo -en "Is this correct? (y/n) "
	read conf

	# Check if the functional runs entered are correct
	if [ ${conf} = y ]
	then
		########## VARIABLE WITH FOLDER PATH #####
		# Assigning the path entered by the user into the definite variable
		analysis_name=${analysis_name_user}
		folder_processing=${folder_processing_user}
		##########################################

		break
	else
		echo -e "\n"
		echo -en "Please correct the folder's path entered "

		# Cleaning the contents for the variable below for correction
		unset folder_processing_user analysis_name_user

		sleep 2
	fi
done

#### PROCESSING FILE containing the CONTRAST names #####
# This will retrieve the names of real contrasts of the design.fsf file of the higher-level analyzes
echo
echo -e "\tThese are the contrasts used for this analysis"
echo -e "\tTheir numbering is equivalent to the cluster files below, i.e., \"constrast 1\" results are reported in \"cluster_Xstat1_XXXX.txt\""

# Creating a file holding the contrasts names
# First checking if the file exists
if [ -f ${folder_processing}/*design.con ]
then
	echo

	# Extracting the text that has the contrast names. Note the sed command that first substitutes a "tab" by an underscore, than another sed command substitutes spaces by underscores
	cat ${folder_processing}/*design.con | sed -n 's!/ContrastName!tstat!p' | awk '{$1=$1}{ print }' | sed 's! !_!g' | tee ${temp_folder}/${analysis_name}_COPE_NAMES.txt
else
	echo
	echo -e "*** WARNING ***: could not find a file named \"design.con\" within the path provided!"
	echo -e "Please correct this before proceeding"

	echo
	echo -en "Press any key to continue, or Ctrl+C to exit "
	read -n 1 anykey
fi

#### PROCESSING FILE containing the CLUSTER information #####
# Collecting the list of cluster_XstatX_std.txt files (clusters of max value)

##### HERE IT IS ASSUMED THAT THERE IS ONLY ONE TYPE OF "stat" file. MUST MODIFY THE COMMANDS BELOW IN CASE THERE ARE MORE THAN ONE "stat" file type (zstat, tstat, fstat, etc) #####

echo
echo -e "\tThese are the clusters results files:\n`ls -1 ${folder_processing}/cluster_*stat?.txt | awk -F/ '{print $NF}'; ls -1 ${folder_processing}/cluster_*stat??.txt 2> /dev/null | awk -F/ '{print $NF}'`\n"

# Storing the CLUSTER_LIST variable content in a text file. Note the use of "?" and "??" to sort files with diferent number of digits in the name
ls ${folder_processing}/cluster_*stat?.txt | awk -F/ '{print $NF}' > ${temp_folder}/${analysis_name}_CLUSTER_LIST.txt
ls ${folder_processing}/cluster_*stat??.txt 2> /dev/null | awk -F/ '{print $NF}' >> ${temp_folder}/${analysis_name}_CLUSTER_LIST.txt ## Redirecting any error from this command in case a subject does not have a Xstat file with 2 digits

#### PROCESSING FILE containing the LOCAL MAXIMA information #####
# Collecting the list of lmax_XstatX_std.txt files (local maxima)

##### HERE IT IS ASSUMED THAT THERE IS ONLY ONE TYPE OF "stat" file. MUST MODIFY THE COMMANDS BELOW IN CASE THERE ARE MORE THAN ONE "stat" file type (zstat, tstat, fstat, etc) #####

echo -e "\tThese are the local maxima results files:\n`ls -1 ${folder_processing}/lmax_*stat?.txt | awk -F/ '{print $NF}'; ls -1 ${folder_processing}/lmax_*stat??.txt 2> /dev/null | awk -F/ '{print $NF}'`\n"

# Storing the LOCALMAX_LIST variable content in a text file. Note the use of "?" and "??" to sort files with diferent number of digits in the name
ls ${folder_processing}/lmax_*stat?.txt | awk -F/ '{print $NF}' > ${temp_folder}/${analysis_name}_LOCALMAX_LIST.txt
ls ${folder_processing}/lmax_*stat??.txt 2> /dev/null | awk -F/ '{print $NF}' >> ${temp_folder}/${analysis_name}_LOCALMAX_LIST.txt 2> /dev/null ## Redirecting any error from this command in case a subject does not have a Xstat file with 2 digits

# Exporting variables to be used in the function "extract_results". TEMPORARY SOLUTION, WILL NEED TO REWRITE THE CODE IN THAT FUNCTION SO IT IS MORE FLEXIBLE WITH THE VARIABLES USED (e.g. "SUBJLIST_local").
SUBJLIST_local=${analysis_name}

##### VARIABLES TO BE USED IN THIS FUNCTION AND SUBSEQUENT ONES #####
# Variable to hold the folder where the scripts results will be saved
script_results_folder=$1 # Used only in the function "extract_results"

# OUTPUT directory defined here
OUTDIR="${folder_processing}/${script_results_folder}" # Used only in the function "extract_results"
#####################################################################
}

function atlas_choice {
# This function allow the user to choose the atlas(es) to be used

# Create a "while" loop so if corrections are needed for the atlases entered
while [ 1 ]
do
	echo -e "\n"
	echo -e "\tPlease choose the atlases to be used by \"atlasquery\"\n"

	echo -e "\tThese are the available atlases:\n"

	# Outputing the atlases in a numbered list
	atlasquery --dumpatlases | sed "=" | sed 'N; s/\n/) /'

	echo
	echo -en "\tPlease enter here the number corresponding to the atlases to be used IN THE ORDER YOU WANT THEM TO APPEAR in the output file (if more than one, separate with space): "
	read atlas_list

	if [ -n "${atlas_list}" ] # Checking if this variable is non-zero in length
	then
		# Collecting the atlases available into a variable to be used in the function "numbered_list" (functionslibr_FSL)
		var1_available=`atlasquery --dumpatlases | sed "=" | sed 'N; s/\n/=/' | sed 's/ /_/g'` # variable with all the files in a numbered list. Note that, since the output of "Atlasquery" has spaces, another sed command is used to transform them into underscore
		var2_list="${atlas_list}" # The numbers chosen by the user corresponding to the files to be used

		# Calling the function "numbered_list_display" to present the atlases available in a numbered list to the user. Note the parameters to be passed on to the function
		numbered_list_display "${var1_available}" "${var2_list}"

		# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
		atlas_list="${files_to_use}"

		echo
		echo -e "\nAtlases entered (IN THE ORDER THEY WILL APPEAR IN THE OUTPUT FILE):\n"

		for atlas in ${atlas_list}
		do
			echo $atlas | sed 's/_/ /g' # This sed command will transform the underscores introduced above into spaces again
		done

		echo
		echo -en "Is this correct? (y/n) "
		read conf

		# Check if the functional runs entered are correct
		if [ ${conf} = y ]
		then
			# Creating a text file to hold the atlases choosen, and redirecting error messages if the file already exists
			touch ${temp_folder}/atlases_chosen_FSL.txt > /dev/null

			# Putting each atlas in the atlas_list variable into a line in the text file
			for atlas in ${atlas_list}
			do
				echo ${atlas} | sed 's/_/ /g' >> ${temp_folder}/atlases_chosen_FSL.txt # Note the use of the sed command to transform space into a colon in order to have an appropriate entry for "atlas" in the "atlasquery" command used later in the script
			done

			# Making the atlases listed in the report header to be in upper case. Note the use of the sed commands: first to transform space into a colon so the output files is correct, and the second is to substitute the introduced underscores in to spaces again for better visualization in the output file
			atlas_list_CAPS=`echo ${atlas_list} | sed 's/ /:/g' | sed 's/_/ /g' | tr '[:lower:]' '[:upper:]'`

			break
		else
			echo -e "\n"
			echo -en "Please correct the atlases entered "

			# Cleaning the contents for the variable below for correction
			unset atlas_list
			unset files_to_use

			sleep 2
		fi
	else
		echo -e "\n"
		echo -en "*** No atlas was entered *** This is needed before proceeding - Please choose at least one "
		sleep 2
	fi
done
}

function extract_results {
# This function will used the collected listing of clusters found and local maxima and feed it to atlasquery
clear

#### Starting the process for feat results report generation ####
echo -e "\n"
echo -e "\tGenerating the results report with the location of activations for each subject/group listed here:\n${SUBJLIST_local}\n"

# Marking the time when processing began
start_processing_time=`current_date_time 2`

# This will retrieve each coordinate listed in the clusters and local maxima for each subject
for SUBJ in ${SUBJLIST_local}
do
	# Giving feedback to the user
	echo -e "\n"
	echo -e "#################################################################################"
	echo -e "\tProcessing feat results for subject/group \"${SUBJ}\""
	echo -e "#################################################################################"

	############################################################################
	# Creating folders to hold the results report
	# Checks if folder for this subject was already created
	chkexistfold=`ls -d ${OUTDIR} 2> /dev/null`

	if [ "${chkexistfold}" != "${OUTDIR}" ]
	then
		echo
		echo -e "No folder to save the analysis report was found!\n"

		if [ X${feat_results} = Xyes ]
		then
			echo -e "Please be sure that a folder like this is created before running this script: \"/${analysis_level}/${script_results_folder}\""

		elif [ X${feat_results} = Xno ]
		then
			echo -e "Please be sure that a folder like this is created before running this script: \"${script_results_folder}\""
			echo -e "The above folder should be located in this path:\n${OUTDIR}"
		fi

		echo
		echo -en "Do you want to create this folder now to continue processing?(y/n) "
		read yesno

		if [ "$yesno" = y ] || [ "$yesno" = Y ]
		then
			# Create folder acording to the date and time results were processed. Using the function "current_date_time" in "functionslibr_FSL" to get the date without spaces.
			date_time_fold=`current_date_time 1`

			mkdir -p ${OUTDIR}/${SUBJ}_${date_time_fold}
		else
			echo -en "\nPress anykey to go back to the main menu "
			read -n1 continue

			exit
		fi
	else
		# Create folder acording to the date and time results were processed. Using the function "current_date_time" in "functionslibr_FSL" to get the date without spaces.
		date_time_fold=`current_date_time 1`

		mkdir ${OUTDIR}/${SUBJ}_${date_time_fold}
	fi
	############################################################################

	# Creating folder for each subject within the "temp" folder
	mkdir ${temp_folder}/${SUBJ}

	############################################################################
	##### Extracting the coordinates for z-max in the CLUSTER_ZSTATS_STD.TXT files #####

	# This will check if there is a column for P-values in the feat results. If so, it means that contrast masking was NOT used by the user in higher-level analysis. If used, contrast masking makes the CLUSTER feat results not contain a "P-value" column - which this script uses if present. This does not affect the LMAX results, as they do not have a "P-value" column. THIS ONLY APPLIES TO FEAT RESULTS.
	# Checking if this is a feat result or not
	if [ X${feat_results} = Xyes ]
	then
		while [ 1 ]
		do
			# Getting the filename for the first cluster file only - since all files will either have or not a P-value column
			first_cluster_file=`cat ${temp_folder}/${SUBJ}_CLUSTER_LIST.txt | sed -n '1p'`

			# Retrieving from the text file listed in variable "first_cluster_file" the value of the 4th column (position of P-value if present)
			contrast_mask=`awk 'NR < 2 {print $4}' ${FULLPATH}/${analysis_level}/${SUBJ}.gfeat/cope1.feat/${first_cluster_file}` # 2012/02/22: Removed the asterisk after the "${SUBJ}" as it was including 2 folders named similarly but an "_OLD" at the end of the file name but before the ".gfeat". Check if this will cause any errors

			# Checking the content of the "contrast_mask" variable. If it is "P", it means there is a P-value column and no contrast masking was used

			#### NOTE 2012/02/23: It seems that even when contrast masking is used, a P-value is reported in FEAT results so this check might not be necessary anymore - the result will always be = "P"

			case $contrast_mask in
			P)
				for cluster in `cat ${temp_folder}/${SUBJ}_CLUSTER_LIST.txt`
				do
					# This summarizes the contents of each cluster_zstatsX_std.txt file to have: cluster number, voxels, P-value, Z-max, and X,Y,Z coordinates. The remainder columns will be after the atlases
					# "NR > 1" makes awk to skip the first line of the file
					awk 'BEGIN {OFS=":"} NR > 1 {print $1,$2,$3,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$4}' ${FULLPATH}/${analysis_level}/${SUBJ}.gfeat/cope1.feat/${cluster} > ${temp_folder}/${SUBJ}/${SUBJ}_zmax_${cluster} # 2012/02/22: Removed the asterisk after the "${SUBJ}" as it was including 2 folders named similarly but an "_OLD" at the end of the file name but before the ".gfeat". Check if this will cause any errors
				done
				break ;;

			Z-MAX)
				for cluster in `cat ${temp_folder}/${SUBJ}_CLUSTER_LIST.txt`
				do
					# This summarizes the contents of each cluster_zstatsX_std.txt file to have only: cluster number, voxels, P-value will be "None" since it does not exist when using contrast masking, Z-max, and X,Y,Z coordinates.
					# "NR > 1" makes awk to skip the first line of the file
					awk 'BEGIN {OFS=":"} NR > 1 {print $1,$2,"None",$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,"None"}' ${FULLPATH}/${analysis_level}/${SUBJ}.gfeat/cope1.feat/${cluster} > ${temp_folder}/${SUBJ}/${SUBJ}_zmax_${cluster} # 2012/02/22: Removed the asterisk after the "${SUBJ}" as it was including 2 folders named similarly but an "_OLD" at the end of the file name but before the ".gfeat". Check if this will cause any errors
				done
				break ;;

			*)
				echo
				echo -e "Unexpected value for the 4th column in the cluster results file\n"

				echo -e "The value found was \"${contrast_mask}\", when it was expected to be either \"P\" or \"Z-MAX\"\n"

				echo -e "You must check the cluster results files for this subject/group \"${SUBJ}\""

				echo -e "Going back to the main menu"
				sleep 3

				exit ;;
			esac
		done

	elif [ X${feat_results} = Xno ]
	then
		# Getting the filename for the first cluster file only - since all files will either have or not a P-value column
		first_cluster_file=`cat ${temp_folder}/${SUBJ}_CLUSTER_LIST.txt | sed -n '1p'`

		for cluster in `cat ${temp_folder}/${SUBJ}_CLUSTER_LIST.txt`
		do
			# This summarizes the contents of each cluster_zstatsX_std.txt file to have only: cluster number, voxels, P-value will be "None" since it does not exist when using contrast masking, Z-max, and X,Y,Z coordinates.
			# "NR > 1" makes awk to skip the first line of the file
			awk 'BEGIN {OFS=":"} NR > 1 {print $1,$2,"None",$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,"None"}' ${folder_processing_user}/${cluster} > ${temp_folder}/${SUBJ}/${SUBJ}_zmax_${cluster}
		done
	fi

	##### Extracting the coordinates for z-max in the LMAX_ZSTATS_STD.TXT files #####
	if [ X${feat_results} = Xyes ]
	then
		for lmax in `cat ${temp_folder}/${SUBJ}_LOCALMAX_LIST.txt`
		do
			# This extracts the contents of each lmax_zstatsX_std.txt file: cluster index, z-max, and X,Y,Z coordinates for local maxima
			# "NR > 1" makes awk to skip the first line of the file
			awk 'BEGIN {OFS=":"} NR > 1 {print $1,$2,$3,$4,$5}' ${FULLPATH}/${analysis_level}/${SUBJ}.gfeat/cope1.feat/${lmax} > ${temp_folder}/${SUBJ}/${SUBJ}_zmax_${lmax} # 2012/02/22: Removed the asterisk after the "${SUBJ}" as it was including 2 folders named similarly but an "_OLD" at the end of the file name but before the ".gfeat". Check if this will cause any errors
		done

	elif [ X${feat_results} = Xno ]
	then
		for lmax in `cat ${temp_folder}/${SUBJ}_LOCALMAX_LIST.txt`
		do
			# This extracts the contents of each lmax_zstatsX_std.txt file: cluster index, z-max, and X,Y,Z coordinates for local maxima
			# "NR > 1" makes awk to skip the first line of the file
			awk 'BEGIN {OFS=":"} NR > 1 {print $1,$2,$3,$4,$5}' ${folder_processing_user}/${lmax} > ${temp_folder}/${SUBJ}/${SUBJ}_zmax_${lmax} # 2012/02/22: Removed the asterisk after the "${SUBJ}" as it was including 2 folders named similarly but an "_OLD" at the end of the file name but before the ".gfeat". Check if this will cause any errors
		done
	fi
	############################################################################

	#######################################################################################################################
	# This will go through each zmax file created and retrieve the clusters z-max coordinates and feed them to atlasquery #
	#######################################################################################################################

	##### Creating the temporary files listing the name of the files with the CLUSTERS listed #####
 	cd ${temp_folder}/${SUBJ}

	if [ X${feat_results} = Xyes ]
	then
		ls ${SUBJ}_zmax_cluster_zstat?_std.txt > cluster_files_temp.txt
		ls ${SUBJ}_zmax_cluster_zstat??_std.txt >> cluster_files_temp.txt 2> /dev/null ## Redirecting any error from this command in case a subject does not have a zstat file with 2 digits

	elif [ X${feat_results} = Xno ]
	then
		ls ${SUBJ}_zmax_cluster_*stat?.txt > cluster_files_temp.txt
		ls ${SUBJ}_zmax_cluster_*stat??.txt >> cluster_files_temp.txt 2> /dev/null ## Redirecting any error from this command in case a subject does not have a zstat file with 2 digits
	fi

	for zmax_file in `cat cluster_files_temp.txt`
	do
		echo -e "\n"
		echo -e "\t##### Retrieving CLUSTERS from this file: \"${zmax_file}\" #####\n"

		# Setting NR_value variable to keep count of each line processed below
		NR_value=1

		if [ X${feat_results} = Xyes ]
		then
			# This will identify the zstat number of the cluster results file being processed
			cope_zstat=`echo ${zmax_file} | sed -n 's/'${SUBJ}'_zmax_cluster_//p' | sed -n 's/_std.txt//p'`

			# This will create a variable holding the stimulus name from the COPE_NAMES.txt file
			# Note the "${cope_zstat} " to diferentiate between "zstat1 heat" and "zstat10 cold"
			cope_stimname=`cat ${temp_folder}/${SUBJ}_COPE_NAMES.txt | grep "${cope_zstat}_" | sed 's! !_!'`

		elif [ X${feat_results} = Xno ]
		then
			# This will identify the zstat number of the cluster results file being processed
			cope_zstat=`echo ${zmax_file} | awk -F_ '{print $NF}' | sed -n 's/.txt//p'`

			# This will create a variable holding the stimulus name from the COPE_NAMES.txt file
			# Note the "${cope_zstat} " to diferentiate between "zstat1 heat" and "zstat10 cold"
# 			cope_stimname=`cat ${temp_folder}/${SUBJ}_COPE_NAMES.txt | grep "${cope_zstat}_" | sed 's!'${cope_zstat}_'!!g'`
			cope_stimname=`cat ${temp_folder}/${SUBJ}_COPE_NAMES.txt | grep "${cope_zstat}_" | sed 's! !_!'`
		fi

		# Creating a loop to avoid processing empty files (those that do not have activation listed)
		if [ -s ${zmax_file} ]
		then
			number_of_lines=`cat -b ${zmax_file} | awk '{print $1}'`

			# Getting the total number of clusters
			total_cluster_lines=`cat -b ${zmax_file} | awk '{print $1}' > total_cluster_lines_temp.txt; sort -nr total_cluster_lines_temp.txt | sed -n '1p'; rm total_cluster_lines_temp.txt`

			# This will create the file to hold the output of atlasquery, with the header tags for the final report
# 			if [ X${feat_results} = Xyes ]
# 			then
				echo -e "Cluster Index:Voxels:P-value:Z-Max:Z-Max X (mm):Z-Max Y (mm):Z-Max Z (mm):LOCATION SIDE:${atlas_list_CAPS}:Z-COG X (mm):Z-COG Y (mm):Z-COG Z (mm):COPE-MAX:COPE-MAX X (mm):COPE-MAX Y (mm):COPE-MAX Z (mm):COPE-MEAN:'-log10(P)" > ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt

# 			elif [ X${feat_results} = Xno ]
# 			then
# 				# Extracting the first line of the CLUSTER file as it contains the appropriate header tags for the output file
#
# 			fi
			# Giving feedback to the user
			echo -e "Total number of CLUSTERS in this file ${zmax_file} = ${total_cluster_lines}"

			for line in ${number_of_lines}
			do
				# Retrieving a line at a time from the cluster list file
				cat -b ${zmax_file} | sed 's!:! !g' | sed 's/^[ \t]*//' | sed -n 's/^'${NR_value}'//p' | sed -n '1p' > zmax_file_temp.txt

				cluster_index=`awk '{print $1}' zmax_file_temp.txt`
				voxels_clust=`awk '{print $2}' zmax_file_temp.txt`
				pvalue_clust=`awk '{print $3}' zmax_file_temp.txt`
				zmax_clust=`awk '{print $4}' zmax_file_temp.txt`
				X_clust=`awk '{print $5}' zmax_file_temp.txt`
				Y_clust=`awk '{print $6}' zmax_file_temp.txt`
				Z_clust=`awk '{print $7}' zmax_file_temp.txt`

				# Variables used after the atlases entries in the output file
				XCOG_clust=`awk '{print $8}' zmax_file_temp.txt`
				YCOG_clust=`awk '{print $9}' zmax_file_temp.txt`
				ZCOG_clust=`awk '{print $10}' zmax_file_temp.txt`
				COPEMAX_clust=`awk '{print $11}' zmax_file_temp.txt`
				XCOPE_clust=`awk '{print $12}' zmax_file_temp.txt`
				YCOPE_clust=`awk '{print $13}' zmax_file_temp.txt`
				ZCOPE_clust=`awk '{print $14}' zmax_file_temp.txt`
				COPEMEAN_clust=`awk '{print $15}' zmax_file_temp.txt`
				LOGP_clust=`awk '{print $16}' zmax_file_temp.txt`

				# Determining the side of activation. In FSL, for X coordinate positive = side right, X negative = left
				if [ $X_clust -lt 0 ]
				then
					location_side_clust=Left
				elif
					[ $X_clust -eq 0 ]
				then
					location_side_clust=Center
				elif
					[ $X_clust -gt 0 ]
				then
					location_side_clust=Right
				fi

				echo -e "\n"
				echo -e "Cluster being processed now for file \"${zmax_file}\": $line of ${total_cluster_lines}"

				# Changing the *** FIELD SEPARATOR *** from space to new line
				# First saving the original IFS variable
				OLD_IFS=$IFS

				# Now changing FIELD SEPARATOR to new line
				IFS=$'\n'

				# This will get the atlasquery output for each coordinate group for each atlas entered by the user
				echo
				echo -en "\tRetrieving CLUSTER location using atlases chosen..."

				for atlas in `cat ${temp_folder}/atlases_chosen_FSL.txt`
				do
					##### Using atlasquery to extract cluster location #####
					# Assigning a variable for the atlasquery output # The sed commands will clean the XML tags from the atlasquery output
					location_temp=`atlasquery -a "${atlas}" -c $X_clust,$Y_clust,$Z_clust | sed 's!<[^>]*>! !g;/^$/d' | sed 's!^ !!'` # This gets the output of atlasquery and strip the XML tags

					location_cluster=`echo $location_temp | sed 's!'"${atlas}  "'!!'` # This removes the atlas name, keeping only the location for it, to facilitate the building of the report later in the script

					# Putting all the locations for each atlas in one variable
					location_cluster_all="$location_cluster_all:$location_cluster"
				done

				# Saving output of CLUSTER location to a text file. No need for colon before the "location_cluster_all" variable, as it already has colon in the beginning of its content
				echo -e "${cluster_index}:${voxels_clust}:${pvalue_clust}:${zmax_clust}:$X_clust:$Y_clust:$Z_clust:${location_side_clust}${location_cluster_all}:${XCOG_clust}:${YCOG_clust}:${ZCOG_clust}:${COPEMAX_clust}:${XCOPE_clust}:${YCOPE_clust}:${ZCOPE_clust}:${COPEMEAN_clust}:${LOGP_clust}" >> ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt

				# Cleaning up the "location_*_all" variables content for the next loop - otherwise it will keep acumulating entries
				unset location_cluster_all

				##############################################################################################
				###### This will retrieve the LOCAL MAXIMA corresponding to the cluster being processed ######
				##############################################################################################

				##### Creating the temporary files listing the name of the files with the LOCAL MAXIMA listed #####
				## This puts files with 1 or 2 digits in its name in correct order

				if [ X${feat_results} = Xyes ]
				then
					ls ${SUBJ}_zmax_lmax_zstat?_std.txt > zmax_lmax_filelist_temp.txt
					ls ${SUBJ}_zmax_lmax_zstat??_std.txt >> zmax_lmax_filelist_temp.txt 2> /dev/null ## Redirecting any error from this command in case a subject does not have a zstat file with 2 digits

				elif [ X${feat_results} = Xno ]
				then
					ls ${SUBJ}_zmax_lmax_*stat?.txt > zmax_lmax_filelist_temp.txt
					ls ${SUBJ}_zmax_lmax_*stat??.txt >> zmax_lmax_filelist_temp.txt 2> /dev/null ## Redirecting any error from this command in case a subject does not have a zstat file with 2 digits
				fi

				# This retrieves the correct lmax file according to the cope determined by the variable "cope_zstat"
				# Note the "${cope_zstat}_" to diferentiate files like "XXX_zstat1_std" and "XXX_zstat10_std"
				if [ X${feat_results} = Xyes ]
				then
					zmax_lmax_file=`cat zmax_lmax_filelist_temp.txt | grep "${cope_zstat}_"`

				elif [ X${feat_results} = Xno ]
				then
					zmax_lmax_file=`cat zmax_lmax_filelist_temp.txt | grep "${cope_zstat}"`
				fi

				# Retrieving the local maxima related to the cluster being processed. It uses the "cluster_index" variable to correlate with its local maxima listed in the "zmax_lmax_file" file
				#### Note that we eliminated the first local maxima with the "sed '1d'" command - as it is a repetition of the cluster maxima ####
				cat ${zmax_lmax_file} | sed -n '/^'${cluster_index}:'/p' | sed '1d' > zmax_lmax_file_temp.txt

				number_of_cluster_lines=`cat -b zmax_lmax_file_temp.txt | awk '{print $1}'`

				# Getting the total number of clusters
				total_lmax_lines=`cat -b zmax_lmax_file_temp.txt | awk '{print $1}' > total_lmax_lines_temp.txt; sort -nr total_lmax_lines_temp.txt|sed -n '1p'; rm total_lmax_lines_temp.txt`

				# Testing if the variable "total_lmax_lines" is empty - in such case the if statement will skip the processing of the local maxima empty file
				if [ -n "${total_lmax_lines}" ] # tests if the variable is non-zero in length
				then
					# Giving feedback to the user
					echo -e "\n"
					echo -e "Number of LOCAL MAXIMA for cluster #${cluster_index} = ${total_lmax_lines}"

					for line_number_lmax in ${number_of_cluster_lines}
					do
						# Isolating the line to processed in the file "zmax_lmax_file_temp.txt"
						cluster_line=`cat -b zmax_lmax_file_temp.txt | sed 's/^[ \t]*//' | sed -n 's/'^${line_number_lmax}'//p'`

						lmax_clustindex=`echo $cluster_line | awk 'BEGIN{FS=":"} {print $1}'`
						zmax_lmax=`echo $cluster_line | awk 'BEGIN{FS=":"} {print $2}'`
						X_lmax=`echo $cluster_line | awk 'BEGIN{FS=":"} {print $3}'`
						Y_lmax=`echo $cluster_line | awk 'BEGIN{FS=":"} {print $4}'`
						Z_lmax=`echo $cluster_line | awk 'BEGIN{FS=":"} {print $5}'`

						# Determining the side of activation. In FSL, for X coordinate positive = side right, X negative = left
						if [ $X_lmax -lt 0 ]
						then
							location_side_lmax=Left
						elif
							[ $X_lmax -eq 0 ]
						then
							location_side_lmax=Center
						elif
							[ $X_lmax -gt 0 ]
						then
							location_side_lmax=Right
						fi

						echo -e "\n"
						echo -e "\tLocal maxima being processed now: ${line_number_lmax} of ${total_lmax_lines}"

						# This will get the atlasquery output for each coordinate group for each atlas entered by the user
						# Giving feedback to the user
						echo -en "\tRetrieving LOCAL MAXIMA location using atlases chosen..."

						for atlas in `cat ${temp_folder}/atlases_chosen_FSL.txt`
						do
							##### Using atlasquery to extract cluster location #####
							# Assigning a variable for the atlasquery output # The sed commands will clean the XML tags from the atlasquery output
							location_temp=`atlasquery -a "${atlas}" -c $X_lmax,$Y_lmax,$Z_lmax | sed 's!<[^>]*>! !g;/^$/d' | sed 's!^ !!'` # This gets the output of atlasquery and strip the XML tags

							location_lmax=`echo $location_temp | sed 's!'"${atlas}  "'!!'` # This removes the atlas name leaving only the location, to facilitate the building of the report later in the script

							# Putting all the locations for each atlas in one variable
							location_lmax_all="$location_lmax_all:$location_lmax"
						done

						# Creating a temporary file to hold the local maxima results, for later export it to the feat results file. Note the use of colons in the beginning so the output will align with the cluster results output
						echo -e "Local maxima:::${zmax_lmax}:$X_lmax:$Y_lmax:$Z_lmax:${location_side_lmax}${location_lmax_all}" >> lmax_results_temp.txt

						# Cleaning up the "location_*_all" variables content for the next loop - otherwise it will keep acumulating entries
						unset location_lmax_all
					done

					# Saving output of LOCAL MAXIMA location from the temporary file to the same text file as for cluster results.
					cat lmax_results_temp.txt >> ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt
				else
					total_lmax_lines=0

					# Giving feedback to the user
					echo -e "\n"
					echo -e "Number of LOCAL MAXIMA for cluster #${cluster_index} = ${total_lmax_lines}\n"

					echo -e "\tThere was only one entry for local maxima which is the same as the cluster maxima - thus local maxima file being processed is empty"
				fi

				# Adding a unit to the NR_value variable
				# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
				NR_value=$[10#${NR_value}+1]

				# Removing temporary files
				rm -f *temp.txt

				# Changing the *** FIELD SEPARATOR *** back to the default
				IFS=$OLD_IFS
			done

			# Calculating total number of voxels activated
			voxels_clust=`cat ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt | awk 'BEGIN {FS=":"; OFS=" "} NR > 1 {print $2}'` # This gives an output with newlines and spaces - using sed here does not take them out
			voxels_clust_SUM=`echo ${voxels_clust} | sed 's/ /+/g' | bc` ## Here sed can substitute spaces by plus signs. Note the use of the "bc" comand, which is the bash calculator
			voxels_clust_SUM=`printf "%'d\n" $voxels_clust_SUM` # Making the number comma separated (thousands)

			# Calculating the number of left/right locations
			location_side=`cat ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt | awk 'BEGIN {FS=":"; OFS=" "} NR > 1 {print $8}'`

			# Declaring the side variables to equal zero to start clean the calculations
			right_side=0
			left_side=0
			center=0

			for side in `echo $location_side`
			do
				if [ $side = Right ]
				then
					right_side=$[ $right_side + 1 ]
				elif
					[ $side = Left ]
				then
					left_side=$[ $left_side + 1 ]
				elif
					[ $side = Center ]
				then
					center=$[ $center + 1 ]
				fi
			done

			# Adding the variables "voxels_clust_SUM" and "right_side, left_side, center" to the text file with cluster results
			echo -e "SUM VOXELS=:$voxels_clust_SUM:::::Total Right=:${right_side}" >> ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt
			echo -e "::::::Total Left=:${left_side}" >> ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt
			echo -e "::::::Total Center=:${center}" >> ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}".txt

			# Cleaning the variables for next loop
			unset right_side left_side center

		else
			echo
			echo -e "CLUSTER LIST FILE \"${zmax_file}\" DOES NOT CONTAIN ANY ACTIVATION LISTED" | tee -a ${temp_folder}/${SUBJ}/${SUBJ}_clust_loc_"${cope_stimname}"_EMPTY.txt
		fi

		#### Starting the process for feat results report generation for files with cluster identified ####
		echo -e "\n"
		echo -e "\tGenerating the results report with the location of activations for:"
		echo -e "\tSubject/Group: ${SUBJ}"
		echo -e "\tClusters file: ${zmax_file}"

		# This will add header information to the report file. Using colon at the end so this will be consistent with the field separator ":" in the results part. Note use of the command "tr" to make the cope name be output in uppercase
		echo -e "#####  FEAT results report with their location  #####:" > ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt

		echo -e "\"zstat\" and \"lmax\" source files for these results located at:\n\"${FULLPATH}/${analysis_level}/${SUBJ}.gfeat/cope1.feat/\":" >> ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt

		echo -e "Report generated in `current_date_time 2`:\n" >> ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt

		# Using the variable "contrast_mask" to determine if contrast masking was used, therefore determining if a p_value is reported (contrast masking used = no P-value)
		if [ "${contrast_mask}" = P ]
		then
			echo -en
		else
			echo -e "*** NOTE - constrast masking was used for FEAT analysis, thus no cluster P-value is reported here ***:\n" >> ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt
		fi

		# Note the use of the command "tr" to convert lowercase characters to uppercase
		echo -e "Subject/group="${SUBJ}:"\nContrast="`echo "${cope_stimname}:" | tr '[:lower:]' '[:upper:]':`"" >> ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt

		echo >> ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt

		# Copying the report to the final folder

		# This will separate the files with "EMPTY" so this word is part of the file name
		empty_file=`ls ${SUBJ}_clust_loc_"${cope_stimname}"*.txt | grep EMPTY`

		# This checks if the "empty_file" has content or not, then saves the file with or without "EMPTY" in the name
		if [ -z "$empty_file" ]
		then
			# Extracting the results from the "clust_loc" file to the final report file
			cat ${SUBJ}_clust_loc_"${cope_stimname}".txt >> ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt
		else
			# Renaming the reports file to have "EMPTY" in the end of the file name
			mv ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}".txt ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}"_EMPTY.txt

			# Extracting the results from the "clust_loc" file to the final report file
			cat ${SUBJ}_clust_loc_"${cope_stimname}"_EMPTY.txt >> ${OUTDIR}/${SUBJ}_${date_time_fold}/${SUBJ}_featresults_"${cope_stimname}"_EMPTY.txt
		fi
	done
done

# Marking the time when processing ended
finish_processing_time=`current_date_time 2`

# Going back to the /tmp folder
cd /tmp
}

function extract_results_cluster {
echo "In construction - Please come back later"
echo -en "\nPress anykey to go back to the main menu "
read -n1 continue
 }

###########################################################################
###############			MAIN MENU ROUTINE			###############
###########################################################################

################ VARIABLES TO BE USED IN THIS SCRIPT #################
# Variable for the folder within "/tmp" for temporary files
temp_folder=/tmp/ppss_tempdir_cluster_location

# Variable holding the location of the 3rdlevel fMRI analysis
analysis_folder_2ndlevel=analysis_BOLD_stim-evoked/2ndlevel

# Variable holding the location of the 3rdlevel fMRI analysis
analysis_folder_3rdlevel=analysis_BOLD_stim-evoked/3rdlevel

######################################################################


######### Script Main menu - Informing the user what this script does and asking for input #########
clear

# Removing all temporary fsf templates and their temp folder within "/tmp" that might be present from previously aborted processing
rm -rf ${temp_folder} 2> /dev/null

# Creating the temp folder
mkdir ${temp_folder} 2> /dev/null

while [ 1 ]
do
	# Changing directory to /tmp in case the script commits some error - this will make any commands to be run within /tmp, preventing damage to the file system
	cd /tmp

	echo
	echo -e "This program will locate activations found from FEAT analysis or from the CLUSTER command\n"

	echo -e "It will use a tool called \"atlasquery\", part of the FSL package"
	echo -e "This program will generate a text file holding the information retrieved, and this can be latter on be imported to an spreadsheet"
	echo -e "You can use it to get activation clusters at any higher-level analysis (subject- or group-level)\n"

	echo -e "Remember that the analysis must already be ran and located at the folder \"analysis/2ndlevel\" or \"analysis/3rdlevel\""
	echo -e "*** NOTE that the first local maxima is always a repetition of the cluster maxima, thus it is deleted from the reports generated here ***\n"

	echo
	echo -e "Do you want to look at the results of:\n"
	echo -e "\t1) FEAT Subject-level analysis"
	echo -e "\t2) FEAT Group-level analysis"
	echo -e "\t3) Other FSL tools analysis"

	echo
	echo -en "Please enter your option here: "

	read subj_group

	case ${subj_group} in
	1)
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "mainscrcall_cluster_location:Locate activation clusters using atlases for FEAT subject-level results" FSL "atlasquery"

		# FUNCTION CALL: Calling the function "rawdata_feat" to collect data, using parameters for the variables used within this function
		rawdata_feat ${analysis_folder_2ndlevel} _SUBJ_FEAT_RESULTS

		# Variable to signal that this is processing FEAT results
		feat_results=yes

		break
		;;
	2)
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "mainscrcall_cluster_location:Locate activation clusters using atlases for FEAT group-level results" FSL "atlasquery"

		# Calling the function "rawdata_feat" to collect data, using parameters for the variables used within this function
		rawdata_feat ${analysis_folder_3rdlevel} _GROUP_FEAT_RESULTS

		# FUNCTION CALL: Variable to signal that this is processing FEAT results
		feat_results=yes

		break
		;;
	3)
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "mainscrcall_cluster_location:Locate activation clusters using atlases for other FSL tools results" FSL "atlasquery"

		# FUNCTION CALL: Calling the function "rawdata_otherFSLtools" to allow the user to select the folders with the files to be processed
		rawdata_otherFSLtools _PROCESSED_RESULTS

		# Variable to signal that this is processing FEAT results
		feat_results=no

		break
		;;
	*)
		echo
		echo -en "No valid option chosen - returning to previous menu "

		sleep 2

		clear
		;;
	esac
done

# Checking if this is FEAT results or not
if [ X${feat_results} = Xyes ]
then
	while [ 1 ]
	do
		# Going to /tmp for safety in case script goes awry
		cd /tmp

		# This will let the user decide if FEAT results will be processed or to use CLUSTER to obtain results using different Z values or P-thresholds
		echo
		echo -e "\tWhich you want to use as input for the cluster location:\n"
		echo -e "\t\t1) List of clusters as generated by FEAT in a previous analysis located on the above listed files or\n"
		echo -en "\t\t2) Choose a different Z threshold and P-value for the clusters (IN CONSTRUCTION)? "
		read cluster_report

		case $cluster_report in
		1)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Using the cluster list generated by FEAT in previously ran analysis"

			# FUNCTION CALL: calling the function "atlas_choice" to allow the user to choose the atlas(es) to be used
			atlas_choice

			# FUNCTION CALL: calling function "extract_results" to retrieve raw data from FEAT results
			extract_results

			# Giving feedback to user
			echo
			echo -e "#################################################################################"
			echo -e "#################################################################################"
			echo
			echo -e "\tGenerated results report with the location of activations for each subject/group listed here:\n${SUBJLIST_local}\n"
			echo -e "\tYou can find the reports in this folder: $OUTDIR\n"
			echo -e "\tTo load these text files in Excel, you can import them as \"text file separated by colon\"\n"
			echo -e "\tProcessing started in: $start_processing_time"
			echo -e "\tProcessing finished in: $finish_processing_time\n"

			echo -en "Press any key to go back to main menu "
			read -n1 anykey

			break ;;
		2)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Using the cluster list generated by the user, calling the FSL \"cluster\" command"

			# Calling function "extract_results_cluster" to process results using the CLUSTER command
			extract_results_cluster

			break ;;
		*)
			echo
			echo -e "No valid option chosen - returning to previous menu\n"
			sleep 3 ;;
		esac
	done

elif [ X${feat_results} = Xno ]
then
	# Creating a log file. STEP 1.5 of 2 = midscript call
	# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
	log_file_scripts_used midscript "Using the cluster list generated by the user for other FSL tools analysis"

	# FUNCTION CALL: calling the function "atlas_choice" to allow the user to choose the atlas(es) to be used
	atlas_choice

	# FUNCTION CALL: calling function "extract_results" to retrieve raw data from FEAT results
	extract_results

	# Giving feedback to user
	echo
	echo -e "#################################################################################"
	echo -e "#################################################################################"
	echo
	echo -e "\tGenerated results report with the location of activations for each subject/group listed here:\n${SUBJLIST_local}\n"
	echo -e "\tYou can find the reports in this folder: $OUTDIR\n"
	echo -e "\tTo load these text files in Excel, you can import them as \"text file separated by colon\"\n"
	echo -e "\tProcessing started in: $start_processing_time"
	echo -e "\tProcessing finished in: $finish_processing_time\n"

	echo -en "Press any key to go back to main menu "
	read -n1 anykey
fi

# Creating a log file. STEP 2 of 2 = finish call
# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 1 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. List of subjects processed
log_file_scripts_used finish "${SUBJLIST}"

# Removing all temporary fsf templates and their temp folder within "/tmp" that might be present from previously aborted processing
rm -rf ${temp_folder} 2> /dev/null