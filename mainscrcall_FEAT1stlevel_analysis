#! /bin/bash

# Script to run FSL 1st level full analysis (prestats+poststats+registration)

# Sourcing of functions library files #
. mainscrcall_funclib

# Setting Ctrl + C as key combination to go back to PROCESSING menu. Also signals to the log file (=if there is one) that this script was interrupted
trap "echo -en '\n\nGoing back to the PROCESSING menu '; sleep 2; log_file_scripts_used interrupt; exit" SIGINT

# Checking if variables are not empty
emptvar=${MEDIA}
var_checked="THE MAIN FOLDER HOLDING MRI DATA"
checkemptvar

emptvar=${EXPERIMENT}
var_checked="THE EXPERIMENT NAME"
checkemptvar

emptvar="${SUBJLIST}"
var_checked="THE SUBJECT(S) TO BE PROCESSED"
checkemptvar

emptvar="${SUBJS_FOLDERS_PATH}"
var_checked="THE FOLDER CONTAINING ALL SUBJECTS' FOLDERS"
checkemptvar

# Checking if the folder for analysis was created
foldercheck=${MEDIA}/${EXPERIMENT}/${analysis_folder}
checkfoldexist2

##########			FUNCTIONS USED IN THIS SCRIPT			##########
function feat_template {
# This function will check if the "feat_templates" folder exists and if so, allow the user to choose the appropriate "design.fsf" file
while [ 1 ]
do
	echo -e "\n"
	echo -e "\tPlease check if you created your FULL ANALYSIs template and it is listed in here:"

	# Testing if "feat_templates is a valid folder
	if [ -d ${FULLPATH}/${feat_templates_folder} ]
	then
		echo
		ls ${FULLPATH}/${feat_templates_folder}/*.fsf | sed 's!'${FULLPATH}/${feat_templates_folder}/'!!' | sed "=" | sed 'N; s/\n/) /'

		# Here the user will choose the template file needed
		echo
		echo -en "Please enter the number corresponding to the .fsf template file of interest from the list above: "
		read feat_template_fullanalysis

		# Collecting the fsf files available into a variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
		var1_available=`ls ${FULLPATH}/${feat_templates_folder}/*.fsf | sed 's!'${FULLPATH}/${feat_templates_folder}/'!!' | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list
		var2_list="${feat_template_fullanalysis}" # The numbers chosen by the user corresponding to the files to be used

		# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
		numbered_list_display "${var1_available}" "${var2_list}"

		# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
		feat_template_fullanalysis=`echo ${files_to_use}` # Need to use echo here instead of just quotes around the variable "files_to_use" in order to eliminate the trailing spaces

		# Cleaning the contents of the variables below
		unset files_to_use

		# Checking if the file chosen above is a .fsf file
		# Assigning a variable with a file extension as output to check if the entered file above is a .fsf file
		fsf_file=`if echo ${FULLPATH}/${feat_templates_folder}/${feat_template_fullanalysis} | grep -q '.fsf'; then echo fsf; else echo wrong; fi`

		# Checking if the full_analysis_template file exists, and if its extension is "fsf"
		if [ -f ${FULLPATH}/${feat_templates_folder}/${feat_template_fullanalysis} ] && [ ${fsf_file} = fsf ]
		then
			echo -e "\n"
			echo -e "The template file ### ${feat_template_fullanalysis} ### exists and it is a .fsf file as needed"

			##### VARIABLE USED IN OTHER PARTS OF THE SCRIPT #####
			# This will create a variable to label the fsf file to be created later in this script
			FEAT_TEMPLATE_USED=`echo ${feat_template_fullanalysis} | sed 's/.fsf//'`

			echo -en "Press any key to continue "
			read -n1 anykey

			break
		else
			echo
			echo -en "Full analysis template file entered does not exist or it is not a .fsf file - please check "

			sleep 2
		fi
	else
		echo
		echo -e "### There is no \"feat_templates\" folder ### here: ${FULLPATH}/${feat_templates_folder}"
		echo -e "Please check this and/or create this folder before proceeding\n"

		echo -en "Press any key to go back to PROCESSING MENU "
		read anykey

		exit
	fi
done
}

function confoundEV_use {
# This function will allow the user to choose the use of confound EV files or not

# Checking with user if common outlier TRs for 2 metrics were generated
echo -e "\n"
echo -e "### Here you can chose how outlier TRs due to head motion are going to be handled ###"
echo -e "You may indicate if a particular type of motion metric confoundEV files is going to be used"
echo -e "Or you can use a confoundEV file that has COMMON outlier TRs for 2 metrics"
echo -e "If a particular run does not have the confoundEV file indicated, it will be processed without adding confoundEVs to the FEAT model\n"

echo -e "Please choose one of the options:\n"

echo -e "\t1) Do *** NOT *** use confound EV files from \"fsl_motion_outliers\" output for processing"
echo -e "\t2) A confoundEV file using a *** PARTICULAR METRIC *** from \"fsl_motion_outliers\" output"
echo -e "\t3) A counfoundEV file with *** COMMON *** outlier TRs for 2 metrics?\n"

echo -en "Enter your option here: "
read confound_choice

if [ ${confound_choice} = 1 ]
then
	# Variable to signal if confoundEVs files are going to be used for FEAT processing
	confoundEV_file_use=no

	# Giving feedback to the user
	echo -e "\n"
	echo -en "*** NO *** confound EV file will be used for this FEAT analysis "

	sleep 1

elif [ ${confound_choice} = 2 ]
then
	# Variable to signal if confoundEVs files are going to be used for FEAT processing
	confoundEV_file_use=yes

	# Variable to signal if a SINGLE or COMMON metric confoundEV file is going to be used
	confound_single_common_metric=single

	while [ 1 ]
	do
		##### Deciding on motion metrics to be collected #####
		echo -e "\n"
		echo -e "\tPlease choose ONE metric for the corresponding confoudEV file to be used\n"

		echo -e "\t1) refrms"
		echo -e "\t2) dvars"
		echo -e "\t3) refmse"
		echo -e "\t4) fd"
		echo -e "\t5) fdrms"

		echo -en "\tPlease enter your option here: "
		read metric_choose_user

		if [ -n "${metric_choose_user}" ] # Checking if this variable is non-zero in length
		then
			# Establishing the initial metric numbering
			metric_number=1

			# Collecting the metrics listed in the "metric_choose_user" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
			var1_available=`for metric in ${metrics_available}; do echo "${metric_number}=${metric}"; metric_number=$[ $metric_number + 1 ]; done` # variable with all the files in a numbered list
			var2_list="${metric_choose_user}" # The numbers chosen by the user corresponding to the files to be used

			# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
			numbered_list_display "${var1_available}" "${var2_list}"

			# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
			metric_calculate="${files_to_use}"

			# Cleaning the contents of the variables below
			unset files_to_use
			unset metric_number

		elif [ -z "${metric_choose_user}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
		then
			metric_choose_user="None chosen!!"
		fi

		# Showing to the user the option entered prior to processing
		echo -e "\n"
		echo -e "This is the metric entered:\n"

		# Making the metrics within the "metric_choose_user" variable to be listed in a numbered list for the user
		# Establishing tne initial metric numbering
		metric_number=1

		for metric in ${metric_choose_user}
		do
			echo "${metric_number}) ${metric}"

			# adding a unit to the numbering variable
			metric_number=$[ $metric_number + 1 ]
		done

		# Cleaning the contents of the numbering variable
		unset metric_number

		echo
		echo -en "Is this correct? (y/n) "
		read yesno

		if [ ${yesno} = y ] || [ ${yesno} = Y ]
		then
			##### PROCESSING VARIABLE #####
			metric_calculate="${metric_choose_user}"
			###############################

			# Going to the processing stage
			break

		elif [ ${yesno} = n ] || [ ${yesno} = N ]
		then
			echo -e "\n"
			echo -en "Please correct the metric to be used "

			sleep 2

			# Cleaning the contents of the variable below
			unset metric_calculate
		fi
	done

elif [ ${confound_choice} = 3 ]
then
	# Variable to signal if confoundEVs files are going to be used for FEAT processing
	confoundEV_file_use=yes

	# Variable to signal if a SINGLE or COMMON metric confoundEV file is going to be used
	confound_single_common_metric=common

	echo -e "\n"
	echo -e "This script will look for confoundEV files with common outlier TRs for 2 metrics as generated by the \"Outliers detection\" option in the PROCESSING menu"
	echo -e "They are going to be identified by the tag \"COMMON\" in their name\n"

	echo -en "Press any key to continue "
	read -n1 anykey
fi
}

function bzero_unwarping {
# This function will process the necessary steps to use fieldmap files to correct EPI distortions

# Checking if the user wants to do EPI distortion correction
echo -e "\n"
echo -e "### Here you can choose if you wish to do EPI distortion correction using FIELDMAPS ###"
echo -e "If positive, the necessary FIELDMAP phase and magnitude files need to be pre-processed and within the expected folders:"
echo -e "a. FIELDMAP phase: already converted to rad/s units, named \"subjID_scandate_fieldmap_BOLD_0X_stdMNI_rads.nii.gz\" within a folder named \"fieldmap_BOLD_0X\" within the \"func\" folder for each subject"
echo -e "b. FIELDMAP magnitude: non-brain tissue extracted, named \"subjID_scandate_fieldmap_BOLD_mag0X_stdMNI_brain.nii.gz\" within a folder named \"fieldmap_BOLD_mag0X\" within the \"func\" folder for each subject"

while [ 1 ]
do
	echo
	echo -e "Please choose if you wish to:"
	echo -e "\t1) *** NOT *** proceed EPI distortion correction using FIELDMAPS"
	echo -e "\t2) *** PROCEED *** EPI distortion correction using FIELDMAPS\n"

	echo -en "Enter your option here: "
	read bzerounwarping_proceed_user

	if [ -n "${bzerounwarping_proceed_user}" ] && [ ${bzerounwarping_proceed_user} = 1 ]
	then
		# Variable to signal if confoundEVs files are going to be used for FEAT processing
		bzerounwarping_proceed=no

		# Giving feedback to the user
		echo -e "\n"
		echo -en "EPI distortion correction file will *** NOT *** be used for this FEAT analysis "

		sleep 1

		break

	elif [ -n "${bzerounwarping_proceed_user}" ] && [ ${bzerounwarping_proceed_user} = 2 ]
	then
		# Variable to signal if confoundEVs files are going to be used for FEAT processing
		bzerounwarping_proceed=yes

		break
	else
		echo
		echo -en "No valid option chosen - please choose again "

		sleep 2
	fi
done
}

function frun_selection_manual {
# This function allows the user to enter manually the FUNCTIONAL runs and ANATOMICAL files to be processed

##### ROUTINE FOR MANUAL COLLECTION OF ALL FUNCTIONAL RUNS AND ANATOMICAL FILE #####
# Colecting info for the FUNCTIONAL files for full analysis
# Uses a "while" loop so if corrections are needed for the functional runs it can be done here
while [ 1 ]
do
	##### Choosing FUNCTIONAL files #####
	echo -e "\n"
	echo -e "\tFUNCTIONAL runs available for ### ${SUBJ} ###:\n"

	ls -d1 ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/frun*${modality_process}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/func/'!!' | sed "=" | sed 'N; s/\n/) /'

	echo
	echo -e "Enter below the number corresponding to the FUNCTIONAL runs to be processed for ### ${SUBJ} ### for design file:"
	echo -e "\"${FEAT_TEMPLATE_USED}\""

	echo
	echo -e "In case this subject has no FUNCTIONAL run for the stimulus type being processed, just hit \"Enter\" to skip it from processing"
	echo -en "Please enter the number(s) here (if more than one, separate with spaces): "
	read funcfolder_list_temp_chosen

	if [ -n "${funcfolder_list_temp_chosen}" ] # Checking if this variable is non-zero in length
	then
		# Collecting the FUNCTIONAL files available into a variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
		var1_available=`ls -d1 ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/frun*${modality_process}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/func/'!!' | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list
		var2_list="${funcfolder_list_temp_chosen}" # The numbers chosen by the user corresponding to the files to be used

		# Calling the function "numbered_list_display" to present the FUNCTIONAL files available in a numbered list to the user. Note the parameters to be passed on to the function
		numbered_list_display "${var1_available}" "${var2_list}"

		# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
		funcfolder_list_temp_chosen="${files_to_use}"

		# Cleaning the contents of the variables below
		unset files_to_use

		##### Choosing ANATOMICAL files #####
		echo
		echo -e "ANATOMICAL file(s) available for subject ### ${SUBJ} ###\n"

		if [ ${fslanat_output_path} = none ]
		then
			# Colecting info for the ANATOMICAL file for full analysis
			anatfile_fullpath=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz 2> /dev/null`
			anatfile_nameonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz 2> /dev/null | awk -F/ '{print $NF}'`

		elif [ ${fslanat_output_path} = subj_anat_folder ]
		then
			# Colecting info for the ANATOMICAL file for full analysis
			anatfile_fullpath=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz 2> /dev/null`
			anatfile_nameonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz 2> /dev/null | awk -F/ '{print $NF}'`

		elif [ ${fslanat_output_path} = separate_folder ]
		then
			# Getting the ANATOMICAL files into a variable to check if there at least one
			anat_files_list_temp=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/*_brain.nii.gz 2> /dev/null`
		fi

		# Checking if the variable "anat_files_list_temp" is empty or not
		if [ -z "${anat_files_list_temp}" ]
		then # Variable "anat_files_list_temp" is empty
			# Giving feedback to the user
			# Checking if the anatomical file to be used has a different path than the subject's "anat" folder
			if [ ${fslanat_output_path} = none ]
			then
				echo
				echo -e "Could not find a valid ANATOMICAL file using the command: ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz"

			elif [ ${fslanat_output_path} = subj_anat_folder ]
			then
				echo
				echo -e "Could not find a valid ANATOMICAL file using the command: ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz"

			elif [ ${fslanat_output_path} = separate_folder ]
			then
				echo
				echo -e "Could not find a valid ANATOMICAL file using the command: ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr_brain.nii.gz"
			fi

			echo
			echo -en "Please enter here the full path to a valid ANATOMICAL file for this subject, or hit enter to skip it: "
			read anat_file_chosen_fullpath_temp

			# Checking if this is a valid file
			if [ -n "${anat_file_chosen_fullpath_temp}" ] && [ -f "${anat_file_chosen_fullpath_temp}" ] # Checking if this variable is not empty, and if it points to a valid file
			then
				# Assigning the path entered by user to a variable
				anat_file_chosen=${anat_file_chosen_fullpath_temp}

				# Creating a variable to signal that this is a special case that has a #### UNIQUE PATH #### to the ANATOMICAL file
				anat_file_specialcase=yes
			else
				# Giving content to the variable below so the user can skip it
				anat_file_chosen="No valid ANATOMICAL file"
			fi
		else # Variable "anat_files_list_temp" is NOT empty
			# Checking if the anatomical file to be used has a different path than the subject's "anat" folder
			if [ ${fslanat_output_path} = subj_anat_folder ]
			then
				ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz 2> /dev/null | awk -F/ '{print $NF}' | sed "=" | sed 'N; s/\n/) /'

			elif [ ${fslanat_output_path} = separate_folder ]
			then
				ls ${anat_file_folder}/${SUBJ}*T1*.anat/*_brain.nii.gz 2> /dev/null | awk -F/ '{print $NF}' | sed "=" | sed 'N; s/\n/) /'
			fi

			echo
			echo -en "Enter the number corresponding to the ANATOMICAL file to be processed for ### ${SUBJ} ###: "
			read anat_file_chosen

			# Collecting the ANATOMICAL files available into a variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
			# Checking if the anatomical file to be used has a different path than the subject's "anat" folder
			if [ ${fslanat_output_path} = subj_anat_folder ]
			then
				var1_available=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz | awk -F/ '{print $NF}' | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list

			elif [ ${fslanat_output_path} = separate_folder ]
			then
				var1_available=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/*_brain.nii.gz | awk -F/ '{print $NF}' | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list
			fi

			var2_list="${anat_file_chosen}" # The numbers chosen by the user corresponding to the files to be used

			# Calling the function "numbered_list_display" to present the FUNCTIONAL files available in a numbered list to the user. Note the parameters to be passed on to the function
			numbered_list_display "${var1_available}" "${var2_list}"

			# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
			anat_file_chosen=`echo ${files_to_use}`

			# Cleaning the contents of the variables below
			unset files_to_use
		fi

		echo
		echo -e "FUNCTIONAL runs entered: ${funcfolder_list_temp_chosen}"
		echo -e "ANATOMICAL file entered: ${anat_file_chosen}"

		echo -en "\nIs this correct? (y/n) "
		read conf

		# Check if the functional runs entered are correct
		if [ ${conf} = y ]
		then
			# Variable to allow or not creation of individualized design file
			proceed_design_file=yes

			# Assigning the variables to be used
			funcfolder_list_temp=${funcfolder_list_temp_chosen}

			# Checking if this is a unique case for path to ANATOMICAL file
			if [ -n "${anat_file_specialcase}" ] && [ ${anat_file_specialcase} = yes ]
			then
				# Using the UNIQUE path to the ANATOMICAL file
				anatfile_fullpath=${anat_file_chosen}

				# Cleaning the contents of the variable below
				unset anat_file_specialcase
			else
				# Checking if the anatomical file to be used has a different path than the subject's "anat" folder
				if [ ${fslanat_output_path} = subj_anat_folder ]
				then
					# Using the DEFAULT path to the ANATOMICAL file
					anatfile_fullpath=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${anat_file_chosen}`

				elif [ ${fslanat_output_path} = separate_folder ]
				then
					# Using the DEFAULT path to the ANATOMICAL file
					anatfile_fullpath=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/${anat_file_chosen}`
				fi
			fi

			break
		else
			echo
			echo -en "Please correct functional runs entered "
			sleep 2
		fi
	else
		echo
		echo -e "Subject \"${SUBJ}\" have no FUNCTIONAL run selected"
		echo -en "Please confirm if this subject should be skipped (y/n): "
		read skip_yesno

		# Confirming with user if this subject is to be skipped from processing or not
		if [ $skip_yesno = y ] || [ $skip_yesno = Y ]
		then
			# Variable to allow or not creation of individualized design file
			proceed_design_file=no

			echo
			echo -en "Skipped subject \"${SUBJ}\" "

			sleep 2

			break
		else
			echo
			echo -en "Please chose the functional runs for subject \"${SUBJ}\" "

			sleep 2
		fi
	fi
done
}

function design_file_createcheck {
# This function will check if the subject being processed should have an individualized "design.fsf" file created
# Checking if this subject should have an individualized design file created
if [ ${proceed_design_file} = yes ]
then
	# Functional files list variable to be used in the "design_file_individualization" function
	funcfolder_list_process="${funcfolder_list_temp}"

	# FUNCTIONAL CALL: function "design_file_individualization" to create an individualized prestats design.fsf file
	design_file_individualization

	# Cleaning the contents of the variable below
	unset proceed_design_file

elif [ ${proceed_design_file} = no ]
then
# 	# This parameter substitution will remove the skipped subject from the variable SUBJLIST_local created earlier
# 	SUBJLIST=${SUBJLIST/$SUBJ/}

	# Gathering the subjects that were skipped to a variable to later present it to the user
	subj_not_processed="${subj_not_processed} ${SUBJ}"

	# Cleaning the contents of the variable below
	unset proceed_design_file
fi
}

function design_file_individualization {
# This function will create the individualized file for the subject being processed
# Giving feedback to the user
echo -e "\n"
echo -e "Creating the individualized design.fsf file for subject ### ${SUBJ} ###\n"

#################################################################
# This will test if functional runs were entered for the subject. If not, the subject will not be processed
# Giving feedback to the user
echo -e "Checking if folders for each FUNCTIONAL runs exist"

cd ${SUBJS_FOLDERS_PATH}/${SUBJ}/func

for frun in ${funcfolder_list_process}
do
	foldercheck=${frun}
	checkfoldexist
done

echo -e "\n"
echo -en "Checking done. Moving on..."

cd /tmp
#################################################################

###### VARIABLES IN THE "design.fsf" TEMPLATE THAT CAN BE SUBSTITUTED BY THIS SCRIPT #####
# "Path of output directory
# Line 36 set fmri(outputdir)

# Set number of functional runs to be processed
# Line 51 set fmri(multiple) 2

#### B0 unwarping options #####
# Perform B0 unwarping yes/no"
# Line 87 set fmri(regunwarp_yn) 0

# B0 unwarp input image for analysis 1
# set unwarp_files(1) "/Users/moanae/mri_testing/subjs/FM0001_20121203/func/fieldmap_BOLD_01/FM0001_20121203_fieldmap_BOLD_01_stdMNI_rads"

# B0 unwarp mag input image for analysis 1
# set unwarp_files_mag(1) "/Users/moanae/mri_testing/subjs/FM0001_20121203/func/fieldmap_BOLD_mag01/FM0001_20121203_fieldmap_BOLD_mag01_stdMNI_brain"
##############################

# Set path of functional run(s) to be processed
# Line 281 set feat_files(1)

#### Confoud EV files use ####
# Set if confound EV text files are to be used
# Line 284 set fmri(confoundevs)

# Path of confound EV text file
#Line ??? set confoundev_files(1)
##############################

# Set path of skull-striped anatomical file
# Line 281 set highres_files(1)
#############################################################################################


###### STARTS SUBSTITUTION OF TEMPLATE VARIABLES #####

# Creating the temporary fsf text file for the FEAT analysis
echo -e "\n\n\n############################################################" > ${temp_folder}/temp_individualized_full_analysis.fsf
echo -e "##### VARIABLES CREATED TO INDIVIDUALIZE THIS ANALYSIS #####" >> ${temp_folder}/temp_individualized_full_analysis.fsf
echo -e "############################################################" >> ${temp_folder}/temp_individualized_full_analysis.fsf

# Loop to go through each functional run folder for each subject
for funcfolder in ${funcfolder_list_process}
do
	# Setting the variable holding the sed commands to delete the appropriate lines of the "design.fsf" template file
	linedelete=""

	##### NUMBER OF FUNCTIONAL RUNS #####
	##### SET NUMBER OF FIRST LEVEL ANALYSES TO BE RUN (HOW MANY FUNCTIONAL RUNS) #####
	# Variable to delete the relevant line in the "design.fsf" template file
	linedelete="${linedelete} | sed '/^set fmri(multiple)/d'"

	varW=1 # Using a variable in case need to modify how many processes to be used
	numfuncRUN=""

	numfuncRUN="\nset fmri(multiple) ${varW}\n"

	##############################
	# Exporting the variable to temporary text files to be later added to the final design.fsf file
	echo -e ${numfuncRUN} > ${temp_folder}/tempnumfuncrun
	cat ${temp_folder}/tempnumfuncrun >> ${temp_folder}/temp_individualized_full_analysis.fsf
	##############################
	###############################################################################

	##### LOCATION OF EACH FUNCTIONAL RUN #####
	##### SET A FEAT_FILE VARIABLE FOR THE LOCATION OF EACH FUNCTIONAL RUN ####
	# Variable to delete the relevant line in the "design.fsf" template file
	linedelete="${linedelete} | sed '/^set feat_files/d'"

	varX=1 # Using a variable in case need to modify how many processes to be used
	feat_FILES=""

	frun=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/${funcfolder}/*_stdMNI.nii.gz`
	feat_FILES=$feat_FILES"\nset feat_files(${varX}) \"${frun}\"\n"

	##############################
	# Exporting the variable to temporary text files to be later added to the final design.fsf file
	echo -e ${feat_FILES} > ${temp_folder}/tempfuncrun
	cat ${temp_folder}/tempfuncrun >> ${temp_folder}/temp_individualized_full_analysis.fsf
	##############################
	###############################################################################

	##### CONFOUND EVS FILES ####
	## CHECK IF CONFOUND EVS FILES ARE TO BE USED (OUTPUT FROM FSL_MOTION_CORRECTION_OUTLIERS). IF YES, SET THE LOCATION OF THE CONFOUND EV FILE FOR EACH FUNCTIONAL RUN -  ##

	# Checking if user want to use confoundEV file for FEAT processing from the contents of variable "confoundEV_file_use"
	if [ ${confoundEV_file_use} = yes ]
	then
		# Variable to delete the relevant line(s) in the "design.fsf" template file
		linedelete="${linedelete} | sed '/^set fmri(confoundevs)/d' | sed '/^set confoundev_files/d'"

		# Variables to be used within this section
		varT=0 # Variable to signal if confoundEV files are going to be used (0 = no; 1 = yes)
		varZ=0 # Variable to count how many confoundEV files will be used

		confoundEV_file_list="" # Variable holding the available confoundEV files
		confoundEV_command="" # Variable holding the command "set fmri(confoundevs)": use confoundEV files yes or no
		confoundEV_files="" # Variable holding the command "set confoundev_files": path to the confoundEV file

		##### CONFOUNDEV FILES FOR FSLMOTIONOUTLIERS OUTPUT FILES #####
		# Checking if the user chose to use a single motion outlier metric output file or a common of 2 metrics
		if [ ${confound_single_common_metric} = single ]
		then
			# Assigning the confoundEV files to a variable
			confoundEV_file_temp=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/${funcfolder}/${path_confoundEVfiles}/*_OUTLIERS_SINGLEMETRIC_${metric_calculate}_confoundEV.txt 2> /dev/null`

			# Adding the contents of the variable "confoundEV_file_temp" to another variable
			confoundEV_file_list="${confoundEV_file_list} ${confoundEV_file_temp}"

		elif [ ${confound_single_common_metric} = common ]
		then
			# Checking if the common confoundEV file is empty or not. THIS #TEST# IS VALID BASED ON NAMING CONVENTION FROM "fsl_motion_outliers" OUTPUTFILES USED IN THE SCRIPT "motion_outliers" OF USING 2 UNDERSCORES TO SEPARATE THE "EMPTY" PART OF THE FILENAME
			common_confoundEV_file=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/${funcfolder}/${path_confoundEVfiles}/*_OUTLIERS_COMMON-*_confoundEV*.txt 2> /dev/null | awk 'BEGIN {FS="__"} {print $2}'`

			if [ X${common_confoundEV_file} = X ] # Checking if this variable is empty. If so, collecting the common confoundEV file
			then
				# Assigning the confoundEV files to a variable
				confoundEV_file_temp=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/${funcfolder}/${path_confoundEVfiles}/*_OUTLIERS_COMMON-*_confoundEV.txt 2> /dev/null`

				# Adding the contents of the variable "confoundEV_file_temp" to another variable
				confoundEV_file_list="${confoundEV_file_list} ${confoundEV_file_temp}"
			fi
		fi
		#################################################################

		##### ASSIGNING CONFOUNDEV FILES TO VARIABLES TU BE USED IN THE DESIGN.FSF FILE #####
		# Checking if this variable is empty - meaning that this subject/functional run has no confoundEVs file. If so, setting number of confoundEVs to zero and the confoundEV files path variable to be empty
		if [ -z "${confoundEV_file_list}" ]
		then # Variable is empty
			# Setting number of confoundEVs to zero
			confoundEV_command="\nset fmri(confoundevs) ${varT}\n"

			# Setting the confoundEV files path variable to be empty
			confoundEV_files=""
		else # variable is not empty
			# Adding a unit to the variable "varT"
			((varT++))

			# Setting number of confoundEVs
			confoundEV_command="\nset fmri(confoundevs) ${varT}\n"

			# Looping through all the available confoundEV files
			for confoundEV_file in ${confoundEV_file_list}
			do
				# Adding a unit to the variable "varZ"
				((varZ++))

				# # Setting number of confoundEVs and the files path variable
				confoundEV_files="$confoundEV_files\nset confoundev_files(${varZ}) \"${confoundEV_file}\""
			done
		fi
		#################################################################

	elif [ ${confoundEV_file_use} = no ]
	then
		# Variable to delete the relevant line(s) in the "design.fsf" template file
		linedelete="${linedelete} | sed '/^set fmri(confoundevs)/d' | sed '/^set confoundev_files/d'"

		# Setting variable to indicate no use of confoundEVs
		confoundEV_command="\nset fmri(confoundevs) 0\n"

		# Setting number of confoundEVs to zero and have the path variable to be empty
		confoundEV_files=""
	fi

	##############################
	# Exporting the variable to temporary text files to be later added to the final design.fsf file
	echo -e ${confoundEV_command} > ${temp_folder}/tempconfoundEV
	cat ${temp_folder}/tempconfoundEV >> ${temp_folder}/temp_individualized_full_analysis.fsf

	echo -e ${confoundEV_files} > ${temp_folder}/tempconfoundEV_location
	cat ${temp_folder}/tempconfoundEV_location >> ${temp_folder}/temp_individualized_full_analysis.fsf
	##############################

	###############################################################################

	##### EPI distortion correction using FIELDMAP files #####
	## CHECK IF FIELDMAP FILES ARE TO BE USED FOR EPI DISTORTION CORRECTION. IF YES, SET THE LOCATION OF THE FIELDMAP FILES (PHASE AND MAGNITUDE) FOR EACH FUNCTIONAL RUN -  ##
	# Checking if user want to use confoundEV file for FEAT processing from the contents of variable "confoundEV_file_use"

	# Variable to delete the relevant line in the "design.fsf" template file
	linedelete="${linedelete} | sed '/^set fmri(regunwarp_yn)/d' | sed '/^set unwarp_files/d' | sed '/^set unwarp_files_mag/d'"

	varB=0 # Has to use a variable, since it can be a value of "0" or "1" depending on having counfounding variables files to be used

	if [ ${bzerounwarping_proceed} = yes ]
	then
		###########################################################################
		##### CHECKING HOW MANY FIELDMAP PHASE FILES EXISTS #####
		# Collecting FIELDMAP phase file(s) for this subject's functional runs
		fieldmap_phase_list=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/fieldmap_${modality_process}_0?/${SUBJ}_fieldmap_${modality_process}_0?_stdMNI_rads.nii.gz 2> /dev/null`

		# Checking if there is more than one FIELDMAP phase file. If yes, allows the user to choose the one to be used.
		# Counting variable
		count=0

		for item in  ${fieldmap_phase_list}
		do
			# Adding a unit for each file within the variable above
			((count++))
		done

		# Checking if the count variable is greater than one (indicating that there is more than one FIELDMAP phase file)
		if [ ${count} -gt 1 ] # If positive, there is MORE than one FIELDMAP phase file
		then
			# Giving feedback to the user
			echo -e "\n"
			echo -e "*** There is more than one FIELDMAP phase file for stimulus-evoked BOLD runs ***"

			# Loop for user's input
			while [ 1 ]
			do
				echo
				echo -e "Please choose from the below files which to use:"

				# Establishing the initial subject numbering
				item_number=1

				for item in ${fieldmap_phase_list}
				do
					# This is to add trailing zeros to this number, so instead of "2" you have "02" for example
					item_number=`printf "%02d" ${item_number}`

					echo -e "\t${item_number}) `echo ${item} | awk -F/ '{print $NF}'`"

					# Adding a unit to the variable item_number
					((item_number++))
				done

				echo
				echo -en "\tPlease enter your option here: "
				read fieldmap_phase_file_user

				if [ -n "${fieldmap_phase_file_user}" ] # Checking if this variable is non-zero in length
				then
					# Establishing the initial numbering
					fieldmap_number=1

					# Collecting the metrics listed in the "fieldmap_phase_file_user" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
					var1_available=`for fieldmap in ${fieldmap_phase_list}; do echo "${fieldmap_number}=${fieldmap}"; ((fieldmap_number++)); done` # variable with all the files in a numbered list
					var2_list="${fieldmap_phase_file_user}" # The numbers chosen by the user corresponding to the files to be used

					# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
					numbered_list_display "${var1_available}" "${var2_list}"

					# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
					fieldmap_phase_file_user="${files_to_use}"

					# Cleaning the contents of the variables below
					unset files_to_use fieldmap_number

				elif [ -z "${fieldmap_phase_file_user}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
				then
					fieldmap_phase_file_user="None chosen!!"
				fi

				# Showing to the user the option entered prior to processing
				echo -e "\n"
				echo -e "This is the FIELDMAP phase file entered: `echo ${fieldmap_phase_file_user}  | awk -F/ '{print $NF}'`"

				echo
				echo -en "Is this correct? (y/n) "
				read yesno

				if [ ${yesno} = y ] || [ ${yesno} = Y ]
				then
					# Proceeding to collect the info for the FIELDMAP files
					##### FIELDMAP phase file #####
					fieldmap_phase_fileonly=${fieldmap_phase_file_user}

					##### FIELDMAP magnitude file #####
					# First, determining the folder number for the FIELDMAP phase file (the matching FIELDMAP magnitude folder will have the same number)
					fieldmapfolder_number=`echo ${fieldmap_phase_file_user} | awk -F/ '{print $NF}' | awk -F_ '{print $5}'`

					fieldmap_mag_fileonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/fieldmap_${modality_process}_mag${fieldmapfolder_number}/${SUBJ}_fieldmap_${modality_process}_mag${fieldmapfolder_number}_stdMNI_brain.nii.gz 2> /dev/null`

					break

				elif [ ${yesno} = n ] || [ ${yesno} = N ]
				then
					echo -e "\n"
					echo -en "Please correct the FIELDMAP phase file to be used "

					sleep 2

					# Cleaning the contents of the variable below
					unset fieldmap_phase_file_user
				fi
			done

		elif [ ${count} -eq 1 ] # If positive, there is ONLY ONE FIELDMAP phase file
		then
			# Proceeding to collect the info for the FIELDMAP files
			##### FIELDMAP phase file #####
			fieldmap_phase_fileonly=${fieldmap_phase_list}

			##### FIELDMAP magnitude file #####
			fieldmap_mag_fileonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/fieldmap_${modality_process}_mag*/${SUBJ}_fieldmap_${modality_process}_mag*_stdMNI_brain.nii.gz 2> /dev/null`
		fi
		###########################################################################

		# Checking if these variables have content
		if [ -n "${fieldmap_phase_fileonly}" ] && [ -n "${fieldmap_mag_fileonly}" ] # In this case, both have contents and EPI distortion correction will proceed
		then
			# Adding a unit to the variable "varB"
			((varB++))

			# Setting the variable that signal for EPI distortion correction
			bzerounwarping="\nset fmri(regunwarp_yn) ${varB}\n"

			# Setting the variable for the FIELDMAP phase file with all details needed for the design.fsf file
			fieldmap_phase_filefull="\nset unwarp_files(${varB}) \"${fieldmap_phase_fileonly}\"\n"

			# Setting the variable for the FIELDMAP magnitude file with all details needed for the design.fsf file
			fieldmap_mag_filefull="\nset unwarp_files_mag(${varB}) \"${fieldmap_mag_fileonly}\"\n"
		else
			echo
			echo -e "*** WARNING *** Could not find either the FIELDMAP phase or magnitude file(s) for subject \"${SUBJ}\""

			echo
			echo -e "You must check the reason before proceeding"
			echo -en "Press any key to continue, or Ctrl+c to abort "
			read -n 1 anykey
		fi

	elif [ ${bzerounwarping_proceed} = no ]
	then
		# Setting the variable that signal for EPI distortion correction
		bzerounwarping="\nset fmri(regunwarp_yn) ${varB}\n"

		# Setting the variable for the FIELDMAP phase file with all details needed for the design.fsf file
		# EMPTY as EPI distortion correction was not chosen by user
		fieldmap_phase_filefull="\nset unwarp_files(${varB}) \"\"\n"

		# Setting the variable for the FIELDMAP magnitude file with all details needed for the design.fsf file
		# EMPTY as EPI distortion correction was not chosen by user
		fieldmap_mag_filefull="\nset unwarp_files_mag(${varB}) \"\"\n"
	fi

	##############################
	# Exporting the variable to temporary text files to be later added to the final design.fsf file
	echo -e ${bzerounwarping} > ${temp_folder}/tempbzerounwarping_yes
	cat ${temp_folder}/tempbzerounwarping_yes >> ${temp_folder}/temp_individualized_full_analysis.fsf

	echo -e ${fieldmap_phase_filefull} > ${temp_folder}/tempbzerounwarping_phase
	cat ${temp_folder}/tempbzerounwarping_phase >> ${temp_folder}/temp_individualized_full_analysis.fsf

	echo -e ${fieldmap_mag_filefull} > ${temp_folder}/tempbzerounwarping_mag
	cat ${temp_folder}/tempbzerounwarping_mag >> ${temp_folder}/temp_individualized_full_analysis.fsf
	##############################

	##########################################################


	##### ANATOMICAL FILE FOR REGISTRATION #####
	##### PATH TO SKULL-STRIPPED ANATOMICAL FILE AND ASSIGNING IT TO EACH FUNCTIONAL RUN #####
	# Variable to delete the relevant line(s) in the "design.fsf" template file
	linedelete="${linedelete} | sed '/^set highres_files/d'"

	varY=1 # Using a variable in case need to modify how many processes to be used
	highres_FILES=""

	highres_FILES="\nset highres_files(${varY}) \"${anatfile_fullpath}\""

	echo -e ${highres_FILES} > ${temp_folder}/tempanatrun
	cat ${temp_folder}/tempanatrun >> ${temp_folder}/temp_individualized_full_analysis.fsf
	###############################################################################

	##### OUTPUT DIR ####
	##### SETTING THE PATH OF OUTPUT FOLDER AND NAME OF FEAT FOLDER. IT WILL HAVE THE SUBJECT NAME AND THE .FSF FILE NAME #####
	# Variable to delete the relevant line(s) in the "design.fsf" template file
	linedelete="${linedelete} | sed '/^set fmri(outputdir)/d'"

	OUTPUT_folder="${FULLPATH}/${analysis_folder}/${SUBJ}_${funcfolder}_${FEAT_TEMPLATE_USED}"
	echo -e "\nset fmri(outputdir) \"${OUTPUT_folder}\"" > ${temp_folder}/tempoutputdir
	cat ${temp_folder}/tempoutputdir >> ${temp_folder}/temp_individualized_full_analysis.fsf
	###############################################################################

	###############################################################################
	# 	Remove original entries in the "design.fsf" template file using a sed command (sed '/^pattern/d') that looks for a pattern than deletes the text line right after it.
	## Note the use of the command "eval", as if it is not used bash does not accept the piping within the variable "linedelete", and gives out an error
	eval cat ${FULLPATH}/${feat_templates_folder}/${feat_template_fullanalysis} "${linedelete}" > ${temp_folder}/temp_full_analysis.fsf
	###############################################################################

	###############################################################################
	# Consolidating all variables added to an individualized *.fsf file for a particular subject
	cat ${temp_folder}/temp_individualized_full_analysis.fsf >> ${temp_folder}/temp_full_analysis.fsf
	mv ${temp_folder}/temp_full_analysis.fsf ${temp_folder}/${SUBJ}_${funcfolder}_${FEAT_TEMPLATE_USED}.fsf
	###############################################################################

	# Removing all temporary files
	rm -f ${temp_folder}/temp*

	cd /tmp
done
}

###########################################################################
###############			MAIN MENU ROUTINE			###############
###########################################################################

################ VARIABLES TO BE USED IN THIS SCRIPT #################
# Variable for the folder within "/tmp" for temporary files
temp_folder=/tmp/ppss_tempdir_FEAT1stlevel

# Variable with the basename for the file holding the commands for PPSS processing
ppss_command_file=1stlevel_fullanalysis_list.txt

# Variable to hold the folder name for the template FEAT files
feat_templates_folder=templates_BOLD_feat_design-files/1stlevel

# Assigning a variable named "modalities_available" to hold the main location of the files generated by this script. This variable HAS to have this name as a function in mainscr_funclib will only accept it named as is.
modalities_available="BOLD ASL"

# Variable holding the location of the 1st_level fMRI analysis
analysis_folder=analysis_BOLD_stim-evoked/1stlevel

# Variable with the specific folder holding the fsl_motion_outlier output files
path_confoundEVfiles=QA_motion/fsl_motion_outliers_output
######################################################################

######### Script Main menu - Informing the user what this script does and asking for input #########
clear

# Changing directory to /tmp in case the script comits some error - this will make any commands to be run within /tmp, preventing damage to the file system
cd /tmp

# Removing all temporary fsf templates and their temp folder within "/tmp" that might be present from previously aborted processing
rm -rf ${temp_folder} 2> /dev/null

# Creating the temp folder
mkdir ${temp_folder} 2> /dev/null

# Giving instructions to the user
echo -e "########################################################"
echo -e "############	FEAT 1st level analysys	###############"
echo -e "########################################################"

echo
echo -e "This script will generate a \"design.fsf\" for each functional run for each subject for FEAT processing"
echo -e "Then run all FEAT processes in parallel by using PPSS or computing cluster"
echo -e "*** All output will be located in this folder: ${FULLPATH}/${analysis_folder} ***"

######################
## Start processing ##
######################
# Creating a log file. STEP 1 of 2 = start call
# Calling the function "log_file_scripts_used" in "mainscrcall_funclib" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
log_file_scripts_used start "mainscrcall_FEAT1stlevel_analysis:Perform first level fMRI analysis using FEAT" FSL "(main script) feat command line"

# Giving feedback to the user
echo -e "\n"
echo -e "\tProcessing 1st level FEAT full analysis (prestats+poststats+registration) for the following subjects:\n"

# Making the subjects within the "SUBJLIST" variable to be listed in a numbered list for the user
# Establishing the initial numbering
count=1

for SUBJ in ${SUBJLIST}
do
	counter=`printf "%02d" ${count}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

	echo "${counter}) ${SUBJ}"

	# Adding a unit to the numbering variable
	((count++))
done

# Cleaning the contents of the numbering variable
unset count counter

# FUNCTIONAL CALL: allowing the user to choose the modalities (BOLD, ASL) to be processed by calling the function "modalities_processing" in "mainscrcall_funclib", and storing those modalities in the variable "MODALITIES_PROCESSING_LIST"
modalities_processing

# Routine to select the anatomical and functional files to be processed and calling the function "design_file_individualization" to generate the individualized design.fsf file

# FUNCTION CALL: Calling function "path_ANATfiles_processing" in "mainscrcall_funclib" to allow the user to enter the common path to the anatomical files for all subjects being processed
path_ANATfiles_processing

echo
echo -e "Here you can choose to run all functional analysis without further input"
echo -e "or you can choose to analyze some of the functional runs"

echo
echo -e "\t *** WARNING *** if you choose to run the analysis without further input, the script will assume a common path to a SINGLE anatomical file named \"*_brain.nii.gz\" within the folder pointed to by the path entered below\n"

echo -e "In case you have more than one skull-stripped anatomical file within that folder, please be sure ONLY the one you desire to use is named accordingly\n"

echo -e "Please choose from the options below:"
echo -e "1) *** SAME STIMULUS TYPE for all functional runs *** Process automatically ALL functional runs available for all subjects; OR\n"

echo -en "2) *** MORE THAN 1 STIMULUS TYPE ACROSS FUNCTIONAL RUNS *** Select which runs for each subject (also select the anatomical file)? "
read frunproc

# Loop to go through each modality to be processed. Has to be before the SUBJLIST loop so all runs for a modality are processed for all subjects at once, instead of each subject has all modalities processed individually
for modality_process in ${MODALITIES_PROCESSING_LIST}
do
	# Warning for the user to check if a full_analysis_template was created
	echo
	echo -e "*** You must have create a \"feat_templates\" folder that holds this analysis template. Please remember that the \"templates\" in the folder name is mandatory for the correct functioning of this program ***\n"

	echo -e "If you did not create yet the FULL ANALYSIS template, press control+C to go back to main menu"
	echo -e "If you need to create the template, use the FEAT GUI to do so and remember to save the file inside the \"feat_templates\" folder"
	echo -e "Also, since the template file name will be used to name the output FEAT folder you should name it with an informative name, e.g. \"full_analysis_stimulustype.fsf\""

	##### Functions to prepare the processing of the "design.fsf" template file #####

	# FUNCTION CALL: Calling function "feat_template" to check if the "feat_templates" folder exists and if so, allow the user to choose the appropriate "design.fsf" file
	feat_template

	############################################################

	##### Functions to allow user to choose which parts are to be modified from the "design.fsf" template file

	# FUNCTION CALL: Calling function "confoundEV_use" to allow the user to choose the use of confound EV files or not
	confoundEV_use

	# FUNCTION CALL: Calling function "bzero_unwarping" to process the necessary steps to use fieldmap files to correct EPI distortions
	bzero_unwarping
	############################################################

	if [ $frunproc = 1 ]
	then
		for SUBJ in ${SUBJLIST}
		do
			# Creating variables to be used in the full analysis script
			# functional files list variable
			echo -e "\n\n"
			echo -e "Checking FUNCTIONAL runs to be processed and ANATOMICAL file for subject #### \"${SUBJ}\" ####\n"

			##### ROUTINE FOR AUTOMATIC COLLECTION OF ALL FUNCTIONAL RUNS AND ANATOMICAL FILE #####
			# Colecting info for the FUNCTIONAL files for full analysis
			# Notice for the "sed" command the use of single quotes around the variables so it can be parsed correctly
			funcfolder_list_temp=`ls -d1 ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/frun*${modality_process}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/func/'!!'`

			# Checking if the anatomical file to be used has a different path than the subject's "anat" folder
			if [ ${fslanat_output_path} = none ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz`
				anatfile_nameonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz | awk -F/ '{print $NF}'`

			elif [ ${fslanat_output_path} = subj_anat_folder ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz`
				anatfile_nameonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz | awk -F/ '{print $NF}'`

			elif [ ${fslanat_output_path} = separate_folder ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr_brain.nii.gz`
				anatfile_nameonly=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr_brain.nii.gz | awk -F/ '{print $NF}'`
			fi

			if [ -n "${funcfolder_list_temp}" ] && [ -f ${anat_file} ] # Has to satisfy both conditions: 1) that the variable "funcfolder_list_temp" has contents, and 2) That the ANATOMICAL image is a file within the above path
			then
				echo
				echo -e "\tFUNCTIONAL runs available for ### ${SUBJ} ###: \n\t`echo ${funcfolder_list_temp}`"

				echo
				echo -e "\tANATOMICAL file to be used for ### ${SUBJ} ###: ${anatfile_nameonly}"

				# Variable to allow or not creation of individualized design file
				proceed_design_file=yes
			else
				echo
				echo -e "\tSkipping subject \"${SUBJ}\" as either no FUNCTIONAL runs OR skull-stripped ANATOMICAL file was found"

				# Variable to allow or not creation of individualized design file
				proceed_design_file=no
			fi

			# FUNCTIONAL CALL: function "design_file_createcheck" to check if the subject being processed should have an individualized "design.fsf" file created files to be processed
			design_file_createcheck
		done

	elif [ ${frunproc} = 2 ]
	then
		while [ 1 ]
		do
			# Allowing the user to choose semi- or fully-automatic choice of functional runs to be processed
			echo
			echo -e "### You can either select the functional runs to be processed by ###"
			echo -e "1. Entering a \"DESCRIPTOR\" in the \"frunXX_modality_stimulustype\" folder name that identifies functional runs for the \"design.fsf\" template file entered"
			echo -e "2. Selecting MANUALLY the functional run(s) for each subject"

			echo
			echo -en "Please enter your option here: "
			read frun_select_mode

			# Menu for user's option
			case ${frun_select_mode} in
			1)
				##### ROUTINE FOR SEMI-MANUAL COLLECTION OF ALL FUNCTIONAL RUNS AND ANATOMICAL FILE #####
				# Colecting info for the FUNCTIONAL files for full analysis
				# Uses a "while" loop so if corrections are needed for the functional runs it can be done here
				while [ 1 ]
				do
					##### Entering a descriptor for "frun" folders #####
					echo
					echo -e "Enter below a DESCRIPTOR tag that is part of the \"frunXX_\" folders to be processed for each subject"
					echo -e "Examples of DESCRIPTOR tags: \"heatpain\", \"mechanical\""

					echo
					echo -e "You should check within each subject's main data folder the appropriate DESCRIPTOR tag for design file:"
					echo -e "\"${FEAT_TEMPLATE_USED}\""

					echo
					echo -en "Please enter the DESCRIPTOR tag: "
					read descriptortag

					if [ -n "${descriptortag}" ] # Checking if this variable is non-zero in length
					then
						for SUBJ in ${SUBJLIST}
						do
							# Colecting info for the FUNCTIONAL files for full analysis
							# Notice for the "sed" command the use of single quotes around the variables so it can be parsed correctly
							funcfolder_list_temp=`ls -d1 ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/frun*${modality_process}*${descriptortag} 2> /dev/null | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/func/'!!'`

							# Checking if the anatomical file to be used has a different path than the subject's "anat" folder
							if [ ${fslanat_output_path} = none ]
							then
								# Colecting info for the ANATOMICAL file for full analysis
								anatfile_fullpath=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz`
								anatfile_nameonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz | awk -F/ '{print $NF}'`

							elif [ ${fslanat_output_path} = subj_anat_folder ]
							then
								# Colecting info for the ANATOMICAL file for full analysis
								anatfile_fullpath=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz`
								anatfile_nameonly=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz | awk -F/ '{print $NF}'`

							elif [ ${fslanat_output_path} = separate_folder ]
							then
								# Colecting info for the ANATOMICAL file for full analysis
								anatfile_fullpath=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/*_brain.nii.gz`
								anatfile_nameonly=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/*_brain.nii.gz | awk -F/ '{print $NF}'`
							fi

							if [ -n "${funcfolder_list_temp}" ] && [ -n "${anatfile_fullpath}" ] && [ -f "${anatfile_fullpath}" ] # Has to satisfy both conditions: 1) that the variable "funcfolder_list_temp" has contents, and 2) That the ANATOMICAL image is a file within the above path
							then
								echo -e "\n"
								echo -e "\tFUNCTIONAL runs available for ### ${SUBJ} ###: `echo ${funcfolder_list_temp}`"

								echo
								echo -e "\tANATOMICAL file to be used for ### ${SUBJ} ###: ${anatfile_nameonly}"

								# Variable to allow or not creation of individualized design file
								proceed_design_file=yes
							else
								# Since could not find either FUNCTIONAL runs OR ANATOMICAL files for the subejct being processed, asking if the user wants to enter them manually or skip this subject from processing
								echo -e "\n"
								echo -e "*** Either no FUNCTIONAL runs OR skull-stripped ANATOMICAL file was found for subject \"${SUBJ}\" ***"

								echo
								echo -e "These are the functional runs available for this subject, if any:"
								ls -d1 ${SUBJS_FOLDERS_PATH}/${SUBJ}/func/frun*${modality_process}* 2> /dev/null

								echo
								echo -e "Do you wanto to:"
								echo -e "1. Enter them manually"
								echo -e "2. Skip this subject from processing"
								echo -en "Please enter your option here: "
								read manualentry_skip

								# Checking the user's option
								if [ ${manualentry_skip} = 1 ]
								then
									# FUNCTIONAL CALL: function "frun_selection_manual" to allow the user to enter manually the FUNCTIONAL runs and ANATOMICAL files to be processed
									frun_selection_manual
								else
									echo
									echo -e "\tSkipping subject \"${SUBJ}\" from processing"

									# Variable to allow or not creation of individualized design file
									proceed_design_file=no
								fi
							fi

							# FUNCTIONAL CALL: function "design_file_createcheck" to check if the subject being processed should have an individualized "design.fsf" file created files to be processed
							design_file_createcheck
						done

						# Asking the user if there additional runs to be processed with a different descriptor
						echo -e "\n"
						echo -e "##############################################################################################"
						echo -en "Do you want to process additional runs with a DIFFERENT feat template AND descriptor?(y/n) "
						read yesno

						if [ -n "${yesno}" ] && [ ${yesno} = y ]
						then
							echo
							echo -e "### ROUTINE to use another feat template file to run additional functional runs ###"

							##### Functions to prepare the processing of the "design.fsf" template file #####

							# FUNCTION CALL: Calling function "feat_template" to check if the "feat_templates" folder exists and if so, allow the user to choose the appropriate "design.fsf" file
							feat_template

							############################################################
						else
							# break command to get out of the "while" loop
							break
						fi
					else
						echo
						echo -e "No DESCRIPTOR tag was entered"
						echo -en "Please enter a valid DESCRIPTOR tag "

						sleep 2
					fi
				done

				break
				;;
			2)
				for SUBJ in ${SUBJLIST}
				do
					# FUNCTIONAL CALL: function "frun_selection_manual" to allow the user to enter manually the FUNCTIONAL runs and ANATOMICAL files to be processed
					frun_selection_manual

					# FUNCTIONAL CALL: function "design_file_createcheck" to check if the subject being processed should have an individualized "design.fsf" file created files to be processed
					design_file_createcheck
				done

				break
				;;
			*)
				echo
				echo -en "No valid option chosen - please choose again "

				sleep 2
				;;
			esac
		done
	fi
done

# Presenting to the user the subjects to be processed, and the ones excluded due to lack of functional runs and/or anatomical file
echo -e "\n\n"
echo -e "The subjects listed below are going to be processed\n"

# Establishing the initial subject numbering
item_number=1

for item in ${SUBJLIST}
do
	item_number=`printf "%02d" ${item_number}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

	echo "${item_number}) $item"

	# Adding a unit to the variable item_number.
	# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
	item_number=$[10#$item_number + 1 ]
done

# Loop to check if subjects are not going to be processed
if [ -n "${subj_not_processed}" ]
then
	echo -e "\n"
	echo -e "Subjects NOT being processed due to no functional runs or anatomical file are listed below\n"

	# Establishing the initial subject numbering
	item_number=1

	for item in ${subj_not_processed}
	do
		item_number=`printf "%02d" ${item_number}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

		echo "${item_number}) $item"

		# Adding a unit to the variable item_number
		item_number=$[10#$item_number + 1 ]
	done
fi

################ ENTER A ROUTINE HERE TO COUNT HOW MANY ITEMS ARE TO  BE PROCESSED #############

echo
echo -en "Press any key to proceed with FSL full analysis processing for the subjects listed above "
read anykey

# This will use the fsf templates above in Feat to do the full analysis processing
echo -e "\n"
# echo -e "### Starting FEAT 1st level analysis processing using design file \"${FEAT_TEMPLATE_USED}\" for all subjects entered ###"
echo -e "### Starting FEAT 1st level analysis processing for all subjects entered ###"

# Consolidating all subjects to be processed in a list within the PPSS file
# for item in `ls ${temp_folder}/*_${FEAT_TEMPLATE_USED}.fsf`
for item in `ls ${temp_folder}/*.fsf`
do
	echo "feat ${item}" >> ${temp_folder}/${ppss_command_file}
done

# Calling the function "parallel_processing_ppss" (mainscrcall_funclib) to run FEAT command. Note 4 parameters: 1) path to the folder holding the temporary files for this script; 2) the name of the files holding the commands for PPSS to run; 3) parameter to indicate that the PPSS log files should be deleted by the function 4) list of unique identifiers for differentiating commands, e.g. a list of subjects. NOT USING THE 4th PARAMETER, SO ALL SUBJECT'S FILES ARE PROCESSED IN A ROW, INSTEAD OF ON A SUBJECT-BY-SUBJECT BASIS (FASTER AND OPTIMIZED USE OF PPSS)
parallel_processing_ppss ${temp_folder} ${ppss_command_file} ppss_function

# Creating a log file. STEP 2 of 2 = finish call
# Calling the function "log_file_scripts_used" in "mainscrcall_funclib" to output the characteristics of this script. It uses 1 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. List of subjects processed
log_file_scripts_used finish "${SUBJLIST}"

# Removing all temporary fsf templates and their temp folder within "/tmp" that might be present from previously aborted processing
rm -rf ${temp_folder} 2> /dev/null