#! /bin/bash

# This script use a FSL tool called "fsl_motion_outliers" to detect outliers due to motion in the functional runs
# It also generates a dummy EV matrix so you can feed into the Feat stats GUI to remove those outliers from analysis

# Sourcing of functions library files #
. mainscrcall_funclib

# Setting Ctrl + C as key combination to go back to PROCESSING menu. Also signals to the log file (=if there is one) that this script was interrupted
trap "echo -en '\n\nGoing back to the PROCESSING menu '; sleep 2; log_file_scripts_used interrupt; exit" SIGINT

# Checking if variables are not empty
emptvar=${MEDIA}
var_checked="THE MAIN FOLDER HOLDING MRI DATA"
checkemptvar

emptvar=${EXPERIMENT}
var_checked="THE EXPERIMENT NAME"
checkemptvar

emptvar="${SUBJLIST}"
var_checked="THE SUBJECT(S) TO BE PROCESSED"
checkemptvar

emptvar="${SUBJS_FOLDERS_PATH}"
var_checked="THE FOLDER CONTAINING ALL SUBJECTS' FOLDERS"
checkemptvar

##########			FUNCTIONS USED IN THIS SCRIPT			##########
function timeseries_selection {
# This function will allow the user to choose the type of timeseries to be processed by "fsl_motion_outliers"

echo -e "\n"
echo -e "First, choose the Time-Series type to be processed:"
echo -e "\t1) Functional BOLD (func_BOLD)"
echo -e "\t2) Resting BOLD (rest_BOLD)"
echo -e "\t3) Functional ASL (func_ASL)"
echo -e "\t4) Resting ASL (rest_ASL)\n"

echo -en "Please enter the number(s) of the chosen type(s) (If more than one, please separate with space): "
read timeseries_type_choose

# Making the timeseries types "timeseries_type_choose" variable to be listed in a numbered list for the user
if [ -n "${timeseries_type_choose}" ] # Checking if this variable is non-zero in length
then
	# Establishing the initial timeseries type numbering
	type_number=1

	# Collecting the metrics listed in the "metric_choose" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (functionslibr_FSL)
	var1_available=`for timeseries_type_item in ${timeseries_type_available}; do echo "${type_number}=${timeseries_type_item}"; type_number=$[ $type_number + 1 ]; done` # variable with all the files in a numbered list
	var2_list="${timeseries_type_choose}" # The numbers chosen by the user corresponding to the files to be used

	# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
	numbered_list_display "${var1_available}" "${var2_list}"

	# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
	timeseries_type_use="${files_to_use}"

	# Cleaning the contents of the variables below
	unset files_to_use type_number

elif [ -z "${timeseries_type_choose}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
then
	echo
	echo -e "*** No timeseries type was choosen ***"
	echo -e "It will use only \"functional\" type in this case\n"

	echo -en "Press any key to continue (you can change this later, if needed) "
	read -n1 anykey
fi
}

function options_user_input {
# Collecting information from the user about the options for fsl_motion_outlier
echo -e "\n"
echo -e "\tPlease choose the \"fsl_motion_outliers\" options to be used"

while [ 1 ]
do
	###### Deciding on TR discard #####
	echo -e "\n"
	echo -en "## OPTION 1. ## Do you need to *** discard TRs *** from each functional run due to non-steady longitudinal magnetization? (y/n) "
	read choose_dummy

	# Adjusting TR removal or not according to user input
	if [ ${choose_dummy} = y ] || [ ${choose_dummy} = Y ]
	then
		echo -e "\n"
		echo -e "You chose to enter the number of TRs to be discarded"

		while [ 1 ]
		do
			echo -e "\n"
			echo -en "\tPlease enter here the number of TRs (dummy scans) to be discarded from the beginning of each functional run (usually between 2-3): "
			read number_dummy

			echo
			echo -e "Number of TRs to be discarded entered: ${number_dummy}"
			echo -en "Is this correct? (y/n) "
			read conf

			# Check if the functional runs entered are correct
			if [ ${conf} = y ]
			then
				break
			else
				echo
				echo -en "\nPlease correct number of TRs to be discarded "
				sleep 2
			fi
		done
	else
		echo -e "\n"
		echo -en "No TRs will be discarded for motion outliers calculations "
		number_dummy="none"

		sleep 1
	fi

	##### Deciding on thresholding for outliers identification #####
	echo -e "\n"
	echo -e "## OPTION 2. ## An outlier is defined, by DEFAULT, using the typical upper limit for boxplots (the 75th percentile + 1.5 times the InterQuartile Range)"
	echo -e "If, for some reason, you want to use an alternative threshold using absolute values it can be done here\n"

	echo -e "Do you want to:"
	echo -e "\t1) Use the DEFAULT threshold (*** RECOMMENDED ***), or"
	echo -en "\t2) Enter an alternative threshold (use an absolute value)? "
	read threshold_choose

	if [ ${threshold_choose} = 1 ] || [ "${threshold_choose}" =  ]
	then
		threshold="default"

	elif [ ${threshold_choose} = 2 ]
	then
		echo -e "\n"
		echo -e "Please enter the thresholds to be used (in absolute value): "
		read threshold
	fi

	##### Deciding on motion metrics to be collected #####
	echo -e "\n"
	echo -e "## OPTION 3. ## Now you must choose the *** motion detection metric(s) *** to be used"
	echo -e "You can choose one or more, and the description for each can be found here: \"http://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FSLMotionOutliers\"\n"

	echo -e "Please choose one or more of the options between:\n"

	echo -e "\t1) refrms: root mean square (RMS) intensity difference of volume N to the reference volume (DEFAULT metric)"
	echo -e "\t2) dvars: RMS intensity difference of volume N to volume N+1 (see Power et al, NeuroImage, 59(3), 2012)"
	echo -e "\t3) refmse: square of the refrms metric (only method for previous fsl_motion_outliers version)"
	echo -e "\t4) fd: frame displacement (average of rotation and translation parameter differences - using weighted scaling, as in Power et al.)"
	echo -e "\t5) fdrms: frame displacement (average of rotation and translation parameter differences - use matrix RMS formulation)\n"

	echo -en "Please enter your option here (if more than one, separate by space; enter \"all\" for the whole list; for default only hit ENTER) FOR NOW ENTER \"all\" until this script includes all metrics: "
	read metric_choose

	if [ -n "${metric_choose}" ] && [ "${metric_choose}" != all ] # Checking if this variable is non-zero in length and does NOT include all metrics listed
	then
		# Establishing the initial metric numbering
		metric_number=1

		# Collecting the metrics listed in the "metric_choose" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (functionslibr_FSL)
		var1_available=`for metric in ${metrics_available}; do echo "${metric_number}=${metric}"; metric_number=$[ $metric_number + 1 ]; done` # variable with all the files in a numbered list
		var2_list="${metric_choose}" # The numbers chosen by the user corresponding to the files to be used

		# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
		numbered_list_display "${var1_available}" "${var2_list}"

		# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
		metric_calculate="${files_to_use}"

		# Cleaning the contents of the variables below
		unset files_to_use
		unset metric_number

	elif [ -n "${metric_choose}" ] && [ "${metric_choose}" = all ] # Checking if this variable is non-zero in length and does include all metrics listed
	then
		metric_calculate="${metrics_available}"

	elif [ -z "${metric_choose}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
	then
		metric_calculate="refrms"
	fi

	# Showing to the user the option entered prior to processing
	echo -e "\n"
	echo -e "These are the options entered for fsl_motion_outliers processing:\n"

	echo -e "Option 1. Dummy scans to be discarded = ${number_dummy}"
	echo -e "Option 2. Outlier detection threshold to be used = ${threshold}"
	echo -e "Option 3. Motion metrics to be calculated = "

	# Making the metrics within the "metric_choose" variable to be listed in a numbered list for the user
	# Establishing tne initial metric numbering
	metric_number=1

	for metric in ${metric_calculate}
	do
		echo "${metric_number}) ${metric}"

		# Adding a unit to the numbering variable
		metric_number=$[ $metric_number + 1 ]
	done

	# Cleaning the contents of the numbering variable
	unset metric_number

	echo
	echo -en "Is this correct? (y/n) "
	read yesno

	if [ ${yesno} = y ] || [ ${yesno} = Y ]
	then
		# Going to the processing stage
		break

	elif [ ${yesno} = n ] || [ ${yesno} = N ]
	then
		echo -e "\n"
		echo -en "Please correct the options to be used "

		sleep 2

		# Cleaning the contents of the variable below
		unset metric_calculate
	fi
done

# This will prepare the command for detection of outliers due to motion in the functional runs in order to be processed using PPSS through the function "parallel_processing_ppss" in functionslibr_FSL

# Entering the /tmp directory just in case any errors occur, it will not mess up the filesystem
cd /tmp

echo -e "\n"
echo -e "\tPreparing to collect information on outliers for each functional run for these subjects:\n"

# Making the subjects within the "SUBJLIST" variable to be listed in a numbered list for the user
# Establishing tne initial subject numbering
subjnumber=1
subjnumber=`printf "%02d" ${subjnumber}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

for subj in ${SUBJLIST}
do
	subjnumber=`printf "%02d" ${subjnumber}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

	echo "${subjnumber}) ${subj}"

	# Adding a unit to the numbering variable. 	# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10. Maybe not needed here since only using a single trailing zero
	subjnumber=$[ 10#$subjnumber + 1 ]
done

# Cleaning the contents of the numbering variable
unset subjnumber

for SUBJ in ${SUBJLIST}
do
	# Checking if there are files listed in the folder for each subject
	if [ -s ${temp_folder}/timeseries_file_list_${SUBJ}.txt ] # The parameter "-s" checks if this file exists and is not empty
	then
		# Looping over each functional run and creating a text file with all functional runs and the respective command to run fsl_motion_outliers
		for FOLDER in `cat ${temp_folder}/timeseries_file_list_${SUBJ}.txt`
		do
			cd ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}

			# Pulling out the name of the functional run without the ".nii.gz" into a variable - we will use this variable to name the output files. Need to look for "_stdMNI.nii.gz" files as they are the ones reoriented to the MNI template. If not found, warn the user and ask to use the non-oriented file "*.nii.gz"
			FRUN=`ls *_stdMNI.nii.gz 2> /dev/null | sed 's!.nii.gz!!'`

			# Checking if there are functional run files named as _stdMNI.nii.gz
			if [ -z "${FRUN}" ]
			then
				echo
				echo -e "*** WARNING - Could not find a \"*_stdMNI.nii.gz\" here: ***"
				echo -e "*** Path: ${SUBJS_FOLDERS_PATH}/${SUBJ}/***"
				echo -e "*** Folder: ${FOLDER} ***"

				echo -e "This means that the functional run was NOT REORIENTED TO THE MNI TEMPLATE yet\n"

				echo -e "This functional run, if present, has the original scanner orientation: `ls *_orig.nii.gz`"
				echo -e "Do you want to:"
				echo -e "1) Use this run as is, or "
				echo -en "2) Exit so you can reorient this run to the MNI template *** (RECOMMENDED) ***? "
				read run_exit

				if [ $run_exit = 1 ]
				then
					echo -e "\n"
					echo -e "Proceeding with the non-MNI oriented functional run in folder \"${FOLDER}\""

					FRUN=`ls *.nii.gz | sed 's!.nii.gz!!'`

				elif [ $run_exit = 2 ]
				then
					echo -e "\n"
					echo -en "Exiting this script "
					sleep 2

					exit
				fi
			fi

			# Going through the options selected by the user
			# Checking for dummy scans to be discarded
			if [ ${number_dummy} != none ] # Checking if this variable is different than "none"
			then
				# Putting the dummy scans entered above into the format needed for fsl_motion_outliers
				dummy_scans="--dummy=${number_dummy}"
			else
				dummy_scans=""
			fi

			# Checking the outlier detection threshold to be used
			if [ ${threshold} != default ] # Checking if this variable is different than "default"
			then
				# Putting the dummy scans entered above into the format needed for fsl_motion_outliers
				threshold_absolute="--thresh=${threshold}"
			else
				threshold_absolute=""
			fi

			# Creating a folder to hold the quality assessment (QA) files to be created, i.e the metric values, graph
			# First, removing a folder previously created if exists
			rm -rf ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output 2> /dev/null

			# Creating the folder
			mkdir -p ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output 2> /dev/null

			# This creates a text file holding the commands to run fsl_motion_outliers for each functional run entered by the function "parallel_processing_ppss" (functionslibr_FSL)

			##### Creating a LOG file with the "asl_file" command used for later QA if needed #####
			# First creating the empty text LOGFILE
			> ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/LOGFILE_fsl_motion_outliers_${FRUN}.txt

			echo "OS name and version: ${os_nameandversion}; Command: fsl_motion_outliers; FSL `cat $FSLDIR/etc/fslversion`; Date and time: `current_date_time 2`" >> ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/LOGFILE_fsl_motion_outliers_${FRUN}.txt

			echo -e "Command fsl_motion_outliers to detect motion outliers and generate confound EV files" >> ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/LOGFILE_fsl_motion_outliers_${FRUN}.txt
			############################################################################################

			##### Loop to go through all metrics chosen by the user in order to create the command file for PPSS processing using "fsl_motion_outliers" tool part of FSL #####
			for metric in ${metric_calculate}
			do
				echo -e "fsl_motion_outliers -i ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/${FRUN}.nii.gz -o ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_confoundEV.txt --${metric} -s ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_metricvals.txt -p ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_graph.png ${dummy_scans} ${threshold_absolute} -v > ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_processinfo.txt" >> ${temp_folder}/${ppss_command_file}

				############################################################################################
				# Adding the command to the LOG FILE
				echo -e "\nfsl_motion_outliers -i ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/${FRUN}.nii.gz -o ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_confoundEV.txt --${metric} -s ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_metricvals.txt -p ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_graph.png ${dummy_scans} ${threshold_absolute} -v > ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_SINGLEMETRIC_${metric}_processinfo.txt" >> ${SUBJS_FOLDERS_PATH}/${SUBJ}/${FOLDER}/QA_motion/fsl_motion_outliers_output/LOGFILE_fsl_motion_outliers_${FRUN}.txt
				############################################################################################
			done
			#################################################

			cd /tmp
		done

		#### Gathering this subject into a variable for processing. This will be used by the function "subjects_processed" in mainscrcall_funclib #####
		subj_process="${subj_process} ${SUBJ}"
	else
		echo -e "\n"
		echo -e "*** ATTENTION - This file that should list all the functional runs either does not exist or is empty *** please check: ${temp_folder}/FUNCRUNLIST_${SUBJ}.txt"

		echo -en "Press any key to continue "
		read -n1 anykey

		# Gathering the subjects that were skipped to a variable to later present it to the user
		subj_NOT_processed="${subj_NOT_processed} ${SUBJ}"
	fi
done
}

function generate_outlier_TR_matrix {
# Function to generate outlier TR matrices that has TRs that were considered outliers by 2 metrics

# Pulling out the name of the functional run without the "_stdMNI.nii.gz" into a variable - we will use this variable to name the output files. Need to look for "_stdMNI.nii.gz" files as they are the ones reoriented to the MNI template.
FRUN=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/*_stdMNI.nii.gz 2> /dev/null | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/'!!' | sed 's!.nii.gz!!'`

##### 1st STEP - Checking if the chosen metrics have confoundEV files available - MATCHING METRICS #####
# Looping through all temp files with the metrics available for each functional run
for item1 in `ls ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outliers_metrics_${SUBJ}__*`
do
	# Retrieving the confoundEV METRICS output files available for this functional run into a variable
	metrics_func_run=`cat ${item1}`

	# Looping throught the metrics chosen by the user (contained in the variable "metric_calculate") and the metrics from the output files to compare them and CHECK FOR MATCHING METRICS
	for item2 in ${metric_calculate} # Metrics chosen by user
	do
		for item3 in ${metrics_func_run} # Metrics available for this func run
		do
			if [ $item2 = $item3 ]
			then
				# Temporary variable with the common TRs. It will be empty if there are no common outlier TRs
				metrics_matching_temp="${metrics_matching_temp} ${item3}"

				# Removing the tested metric so it does not unnecessarily compare it again
				metric_calculate=${metric_calculate/$item2/}
				metrics_func_run=${metrics_func_run/$item3/}
			fi
		done
	done
done

# Taking out the spaces from the variable "metrics_matching_temp" contents for testing if it has contents below
metrics_matching_temp_nospaces=`echo ${metrics_matching_temp} | sed 's/ //g'`

# Checking if there are matching metrics, and if not putting "none" as the content for variable "metrics_matching"
if [ X${metrics_matching_temp_nospaces} != X ] # In this case the variable "metrics_common_temp_nospaces" has contents
then
	# Transfering from the temporary variable into the final one the MATCHING METRICS
	metrics_matching="${metrics_matching_temp}"
else
	# In this case the variable "metrics_common_temp_nospaces" is empty
	metrics_matching=none
fi

##### 2nd STEP - Checking if the matching metrics have outliers in common #####

# Checking the result for matching metrics
if [ "${metrics_matching}" != none ] # In this case, the metrics chosen by the user have confoundEV output files available
then
	# Variable to count how many matching metrics are available
	metrics_matching_number=0

	# Loop through each of the matching metrics to generate a file with the outlier TRs for each metric
	for item in ${metrics_matching}
	do
		# Adding a unit to the variable "metrics_matching_number"
		metrics_matching_number=$[ $metrics_matching_number + 1 ]

		# Retrieving the outlier TRs for the metric being processed
		outliers_TR_temp=`cat ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/*_OUTLIERS_SINGLEMETRIC_${item}_processinfo.txt | grep "Found spikes at" | sed 's/Found spikes at//'`

		# Taking out the spaces from the variable "outliers_TR_temp" contents
		outliers_TR_temp_nospaces=`echo ${outliers_TR_temp} | sed 's/ //g'`

		# Checking if the variables below are not empty
		if [ X${outliers_TR_temp_nospaces} = X ] # The variable is empty meaning there are no outlier TRs
		then
			echo "${outliers_TR_temp}" > ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outlier_TRs_${item}_EMPTY
		else # There are outlier TRs
			# Outputing the outlier TRs list into a file
			echo "${outliers_TR_temp}" > ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outlier_TRs_${item}_CONTENTS
		fi
	done

	# Collecting the total number of matching metrics. FOR NOW IT CAN ONLY COMPARE 2 METRICS. IN THE FUTURE EXPAND THE CODE TO ACCEPT AS MANY METRICS AS ENTERED BY THE USER
	metrics_matching_total=${metrics_matching_number}

	# Loop to retrieve the metrics with outlier TRs
	for item in `ls ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outlier_TRs_*_*`
	do
		# Gathering what metric this file belongs to. Metric is the 2nd parameter from right to left
		metric_file=`echo $item | awk 'BEGIN {FS="_"} { print ( $(NF - 1) ) }'`

		# Checking the metric outlier TRs being processed. The metrics available in "fsl_motion_outliers" are hard-coded here, meaning that if additional metrics are available in updates to "fsl_motion_outliers" they need to be added by hand to the code here.
		if [ ${metric_file} = fd ]
		then
			# Adding the contents from "$item" into an array (NOT A VARIABLE)
			declare -a outliers_fd=(`cat $item`)

		elif [ ${metric_file} = dvars ]
		then
			declare -a outliers_dvars=(`cat $item`)
		fi
	done

	# Initializing the arrays that will contain the common outlier TRs: 1) indexes; and 2) values. This is only to ensure that this array is empty before processing the loop below
	outliers_common_temp_index=()
	outliers_common_temp_value=()

	# NEED TO FIND A WAY FOR THE SCRIPT TO "KNOW" WHICH METRICS ARE BEING USED FOR OUTLIER TRs COMPARISON. HERE IT IS HARD-CODED FOR "fd" and "dvars"

	# Loop to go through the outlier TRs for matching metrics to compare them and extract the TR common to both
	for value1 in "${outliers_fd[@]}" # This will be the file "outlier_TRs_*_1" with its full path
	do
		for value2 in "${outliers_dvars[@]}"
		do
			if [ "${value1}" = "${value2}" ]
			then
				##### Retrieving the index number for "value2" in the array "outliers_dvars" #####
				index=0
				while [ "${outliers_dvars[$index]}" != "$value2" ] && [ $index -lt "${#outliers_dvars[@]}" ]
				do
					((index++))
				done
				##### #####

				# Since the array index start at "0", and the columns numbering in the confoundEV files start at "1", need to create another variable with value of "index + 1"
				index_adjusted=$[ $index + 1 ]

				# Array with the index of common TRs within the array "outliers_dvars". It will be empty if there are no common outlier TRs
				outliers_common_temp_index+=("${index_adjusted}")

				# Array with the value of common TRs within the array "outliers_dvars". It will be empty if there are no common outlier TRs
				outliers_common_temp_value+=("${value2}")

				# Temporary variable with the common TRs. It will be empty if there are no common outlier TRs
				outliers_common_temp="${outliers_common_temp} ${value2}"
			fi
		done
	done

##### THE LOOP ABOVE OUTPUTS CONTENTS IF ONE OF THE METRICS HAS CONFOUNDEV FILES AVAILABLE. NEED TO FIND A WAY TO MAKE IT SIGNAL SUCCESS ONLY IF BOTH VARIABLES HAVE CONFOUNDEV FILES AVAILABLE.

	# Taking out the spaces from the variable "outliers_fd_dvars_common_temp" contents
	outliers_common_temp_nospaces=`echo ${outliers_common_temp} | sed 's/ //g'`

	# Cleaning the contents of the variable below
	unset outliers_common_temp

	# Checking if there are common outlier TRs, and if not putting "none" as the content for variable "outliers_fd_dvars_common"
	if [ X${outliers_common_temp_nospaces} != X ] # In this case the variable "outliers_fd_dvars_common_temp" has contents
	then
		# Transfering the outlier TRs from the temporary variable into the final one. INDEX REFERS TO ARRAY "
		outliers_common_index="${outliers_common_temp_index[@]}"

		# Transfering the outlier TRs from the temporary variable into the final one
		outliers_common_value="${outliers_common_temp_value[@]}"
	else
		# In this case the variable "outliers_fd_dvars_common_temp" is empty
		outliers_common_index=none

		outliers_common_value=none
	fi
else # In this case, the metrics chosen by the user do not have the corresponding confoundEV files available
	echo
	echo -e "*** WARNING - metrics chosen to be processed do not have the corresponding confoundEV output files for the functional run as generated by \"fsl_motion_outliers\""
	echo -e "These are needed for this script processing\n"

	echo -e "Please ran \"Motion outlier detection\" option in the PROCESSING menu and chose the desired metric before running the present script\n"

	echo -n "Press any key to skip processing this functional folder "
	read -n1 anykey
fi

##### 3rd STEP - Generating the compound confound matrix #####

# Substituting the space between the metrics in the variable "metrics_matching" to a dash
metrics_matching_dash=`echo "COMMON${metrics_matching}" | sed 's/ /-/g'`

# Giving feedback to the user and outputing the processing info to a file
echo -e "\n"
echo "Functional folder: ${timeseries_run_folder}" | tee ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_${metrics_matching_dash}_processinfo.txt

echo "Outliers for metric fd: ${outliers_fd[@]}" | tee -a ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_${metrics_matching_dash}_processinfo.txt

echo "Outliers for metric dvars: ${outliers_dvars[@]}" | tee -a ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_${metrics_matching_dash}_processinfo.txt

echo "Outliers common array index dvars + 1 (match confoundEV columns): ${outliers_common_index}" | tee -a ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_${metrics_matching_dash}_processinfo.txt

echo -e "Outliers common array values dvars: ${outliers_common_value}" | tee -a ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_${metrics_matching_dash}_processinfo.txt

# Checking if there are common outlier TRs to report
if [ "${outliers_common_index}" != none ]
then
	# Initializing the array that will contain the print command for awk. This is only to ensure that this array is empty before processing the loop below
	awk_print_command_parameters=()
	awk_variables=()

	# Initializing the array that will contain the variable names for the print command for awk. This is because awk does not accept variable names that begin with digits. All letters from the alphabet should be enough x 10, as it is unlikely that there will be more than 260 common outlier TRs - May need to expand this array if this does not hold true
	awk_variable_names=(a0 b0 c0 d0 e0 f0 g0 h0 i0 j0 k0 l0 m0 n0 o0 p0 q0 r0 s0 t0 u0 v0 w0 x0 y0 z0 a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2 k2 l2 m2 n2 o2 p2 q2 r2 s2 t2 u2 v2 w2 x2 y2 z2 a3 b3 c3 d3 e3 f3 g3 h3 i3 j3 k3 l3 m3 n3 o3 p3 q3 r3 s3 t3 u3 v3 w3 x3 y3 z3 a4 b4 c4 d4 e4 f4 g4 h4 i4 j4 k4 l4 m4 n4 o4 p4 q4 r4 s4 t4 u4 v4 w4 x4 y4 z4 a5 b5 c5 d5 e5 f5 g5 h5 i5 j5 k5 l5 m5 n5 o5 p5 q5 r5 s5 t5 u5 v5 w5 x5 y5 z5 a6 b6 c6 d6 e6 f6 g6 h6 i6 j6 k6 l6 m6 n6 o6 p6 q6 r6 s6 t6 u6 v6 w6 x6 y6 z6 a7 b7 c7 d7 e7 f7 g7 h7 i7 j7 k7 l7 m7 n7 o7 p7 q7 r7 s7 t7 u7 v7 w7 x7 y7 z7 a8 b8 c8 d8 e8 f8 g8 h8 i8 j8 k8 l8 m8 n8 o8 p8 q8 r8 s8 t8 u8 v8 w8 x8 y8 z8 a9 b9 c9 d9 e9 f9 g9 h9 i9 j9 k9 l9 m9 n9 o9 p9 q9 r9 s9 t9 u9 v9 w9 x9 y9 z9)

	# Setting the index value to 0
	index=0

	# Loop to create the print command parameters for awk. It will be created as the content of a variable since the number of columns to be printed will vary for each functional run according to the number of common outlier TRs found
	for item in ${outliers_common_index} # looping through all index values for the array "outliers_dvars"
	do
		awk_print_command_parameters+=(\$${awk_variable_names[$index]}) # This array will have the parameters using letters, e.g. $a $b $c. Notice the escaping of the "$" symbol in order for it to appear in the array content

		awk_variables+=("-v ${awk_variable_names[$index]}=${item}")

		((index++)) # Adding a unit to this variable to use the next value in the array "awk_variable_names"
	done

	# Creating the awk script using the print command from above
	echo "BEGIN {OFS=\"\t\"} {print `echo ${awk_print_command_parameters[@]} | sed 's/ /, /g'`}" > ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/awk_print

	for item in `cat ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outliers_confoundEV_filelist_${SUBJ}__${timeseries_run_folder}`
	do
		# Gathering the metric of the confoundEV file being processed
		metric_file_processed=`echo $item | awk 'BEGIN {FS="_"} { print ( $(NF-1) ) }'`

		# This extracts the confoundEV columns from the dvars confoundEV file, as the fd confoundEV file has one more row than the number of TRs - it may be a bug in fsl_motion_outliers for the fd metric - see FSL mailing list msg from 2012 Oct 22
		if [ ${metric_file_processed} = dvars ]
		then
			# Extracting the columns that refers to the common outlier TRs from the file of confoundEV for dvars. Notice that the array "outliers_common_index" has the index numbers referring to the correct columns
			awk -f ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/awk_print `echo ${awk_variables[@]}` $item > ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_${metrics_matching_dash}_confoundEV.txt
		fi
	done
else
	# Creating an empty file for the functional run under processing to signal that no common outlier TRs are present for the 2 metrics chosen by the user
	> ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/${FRUN}_OUTLIERS_${metrics_matching_dash}_confoundEV__EMPTY.txt
fi
}

###########################################################################
###############			MAIN MENU ROUTINE			###############
###########################################################################

##### 			VARIABLES TO BE USED IN THIS SCRIPT 		#####
# Assigning a variable to hold the main location of the files generated by this script
temp_folder=/tmp/ppss_tempdir_motionoutliers
ppss_command_file=subject_motion_outliers.txt

# metrics_available="refrms dvars refmse fd fdrms"
metrics_available="dvars fd" # Only allowing the use to choose these 2 metrics as the script cannot handle the other ones yet

# Variable with all modalities that can be processed within this script
timeseries_type_available="func_BOLD rest_BOLD func_ASL rest_ASL"
######################################################################

# Script Main menu - Informing the user what this script does and asking for input
clear

# Changing directory to /tmp in case the script comits some error - this will make any commands to be run within /tmp, preventing damage to the file system
cd /tmp

# Removing temporary folders and files created, just in case they were not deleted properly by a previously ran script
rm -r ${temp_folder} 2> /dev/null

# Creating a temporary folder to hold the text file with the subjects to be processed
mkdir ${temp_folder} 2> /dev/null

# Giving instructions to the user
while [ 1 ]
do
	echo
	echo -e "This program can be used to look for outliers in BOLD or ASL time-series (functional/resting) runs secondary to motion"
	echo -e "It can also generate a confound outlier matrix for those TRs identified by 2 or more metrics, in order to be used as a confoundEV within a GLM framework\n"

	echo -e "\tDo you want to:"
	echo -e "\t\t1) Run outliers detection for BOLD/ASL time-series; OR"
	echo -en "\t\t2) Generate compound confoundEV outlier matrices, i.e., from more than one metric? "
	read main_option

	case ${main_option} in
	1)
		clear

		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "motion_outliers:Detection of outliers TRs due to head motion" FSL "(options_user_input) fsl_motion_outliers"

		echo -e "\n"
		echo -e "*** Outlier detection search ***"
		echo -e "It will use a tool called \"fsl_motion_outliers\", part of the FSL package"
		echo -e "Four files will be generated by this program:\n"

		echo -e "1. Text file with the verbose processing info, including the number of outliers found - named \"Time-Series-filename__OUTLIERS_\"metricname\"_processinfo.txt\""
		echo -e "2. Text file with the values (for each volume) for the chosen motion metric - named \"Time-Series-filename_OUTLIERS_\"metricname\"_metricvals.txt\""
		echo -e "3. Graphical plot from the values (for each volume) for the chosen motion metric - named \"Time-Series-filename_OUTLIERS_\"metricname\"_graph.png\""
		echo -e "4. *** Confound EV file that can be used in FEAT to remove those outliers from analysis *** - named \"Time-Series-filename_OUTLIERS_\"metricname\"_confoundEV.txt\n"

		echo -e "All files will be located within the folder of the respective Time-Series run"

		# Loop for user enter info needed
		while [ 1 ]
		do
			# FUNCTION CALL: Calling function "timeseries_selection" to select which timeseries types to be processed
			timeseries_selection

			echo -e "\n"
			echo -e "Also, please choose if you want to either:"
			echo -e "\t1) Run outliers detection for ALL Time-Series runs for ALL SUBJECTS or"
			echo -e "\t2) Choose which Time-Series runs for each subject?\n"

			echo -en "Please enter the corresponding number(s) of your choice: "
			read all_some

			echo
			echo -e "You entered the following:"
			echo -e "\tTime-Series types: ${timeseries_type_use}"
			echo -e "\tProcess ALL (1) or SELECTED runs (2): ${all_some}"

			echo
			echo -en "Is this correct? (y/n) "
			read yesno

			if [ ${yesno} = y ] || [ ${yesno} = Y ]
			then
				# Going to the processing stage
				break

			elif [ ${yesno} = n ] || [ ${yesno} = N ]
			then
				echo -e "\n"
				echo -en "Please correct the options entered "

				sleep 2

				# Cleaning the contents of the variable below
				unset timeseries_type_use all_some
			fi
		done

		# Looping through subjects list for processing
		for SUBJ in ${SUBJLIST}
		do
			if [ ${all_some} = 1 ]
			then
				# Listing all timeseries runs for this subject
				echo -e "\n"
				echo -e "\tChecking Time-Series runs to be processed for subject \"${SUBJ}\""

				# Looping through each timeseries type
				for item1 in ${timeseries_type_use}
				do
					# Checking the image modality being processed (FUNCTIONAL or RESTING BOLD/ASL).
					if [ ${item1} = func_BOLD ]
					then
						# Variables for path to the files being processed
						timeseries_type_folder=func
						timeseries_type_filename=frun

						image_type_contrast="FUNCTIONAL BOLD"
						modality_contrast=BOLD

					elif [ ${item1} = rest_BOLD ]
					then
						# Variables for path to the files being processed
						timeseries_type_folder=rest
						timeseries_type_filename=resting

						image_type_contrast="RESTING BOLD"
						modality_contrast=BOLD

					elif [ ${item1} = func_ASL ]
					then
						# Variables for path to the files being processed
						timeseries_type_folder=func
						timeseries_type_filename=frun

						image_type_contrast="FUNCTIONAL ASL"
						modality_contrast=ASL

					elif [ ${item1} = rest_ASL ]
					then
						# Variables for path to the files being processed
						timeseries_type_folder=rest
						timeseries_type_filename=resting

						image_type_contrast="RESTING ASL"
						modality_contrast=ASL
					fi

					# Using the -d option of ls will list directories contained in this folder, and not files. The sed function removes the path but preserves the folder name ("func" or "rest") as it is needed for the "options_user_input" function
					timeseries_file_list=`ls -d ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_type_filename}*_${modality_contrast}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/'!!'`

					# Giving feedback to the user
					echo -e "\n"

					echo -en "These are the `echo ${image_type_contrast}` timeseries runs for subject ### ${SUBJ} ###:\n`echo ${timeseries_file_list} | sed 's!'${timeseries_type_folder}/'!!g'` "

					# Looping to put all files in a single line separated by SPACE. This file will be read by the "cat" command in the function "options_user_input"
					for item2 in ${timeseries_file_list}
					do
						timeseries_file_list_export="${timeseries_file_list_export} ${item2}"
					done

					# Storing the "timeseries_file_list_export" variable content in a text file. No need to create this file empty, as it has no input from the user at this point (thus no possibility of keeping entries to it from previous loops)
					echo "${timeseries_file_list_export}" >> ${temp_folder}/timeseries_file_list_${SUBJ}.txt

					# Cleaning contents of variable below
					unset timeseries_file_list timeseries_file_list_export
				done

				# To give time to user to read output between subjects processed
				sleep 1

			elif [ ${all_some} = 2 ]
			then
				# Listing all timeseries runs for this subject
				echo -e "\n"
				echo -e "\tChecking Time-Series runs to be processed for subject \"${SUBJ}\""

				while [ 1 ]
				do
					# Looping through each timeseries type
					for item1 in ${timeseries_type_use}
					do
						if [ ${item1} = func_BOLD ]
						then
							# Variables for path to the files being processed
							timeseries_type_folder=func
							timeseries_type_filename=frun

							image_type_contrast="FUNCTIONAL BOLD"
							modality_contrast=BOLD

							# Collecting all timeries runs available for subject into a variable
							timeseries_file_list_temp1=`ls -d ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_type_filename}*_${modality_contrast}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/'!!'`

							# Looping to put all files in a single line separated by semicolon
							for item2 in ${timeseries_file_list_temp1}
							do
								timeseries_file_list_export1="${timeseries_file_list_export1}${item2}:"
							done

							# Storing the "timeseries_file_list_export" variable content in a text file. No need to create this file empty, as it has no input from the user at this point (thus no possibility of keeping entries to it from previous loops)
							echo "${item1}:${timeseries_file_list_export1}" >> ${temp_folder}/timeseries_file_list_${SUBJ}_TEMP.txt

						elif [ ${item1} = rest_BOLD ]
						then
							# Variables for path to the files being processed
							timeseries_type_folder=rest
							timeseries_type_filename=resting

							image_type_contrast="RESTING BOLD"
							modality_contrast=BOLD

							# Collecting all timeries runs available for subject into a variable
							timeseries_file_list_temp2=`ls -d ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_type_filename}*_${modality_contrast}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/'!!'`

							# Looping to put all files in a single line separated by semicolon
							for item2 in ${timeseries_file_list_temp2}
							do
								timeseries_file_list_export2="${timeseries_file_list_export2}${item2}:"
							done

							# Storing the "timeseries_file_list_export" variable content in a text file. No need to create this file empty, as it has no input from the user at this point (thus no possibility of keeping entries to it from previous loops)
							echo "${item1}:${timeseries_file_list_export2}" >> ${temp_folder}/timeseries_file_list_${SUBJ}_TEMP.txt

						elif [ ${item} = func_ASL ]
						then
							# Variables for path to the files being processed
							timeseries_type_folder=func
							timeseries_type_filename=frun

							image_type_contrast="FUNCTIONAL ASL"
							modality_contrast=ASL

							# Collecting all timeries runs available for subject into a variable
							timeseries_file_list_temp3=`ls -d ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_type_filename}*_${modality_contrast}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/'!!'`

							# Looping to put all files in a single line separated by semicolon
							for item2 in ${timeseries_file_list_temp3}
							do
								timeseries_file_list_export3="${timeseries_file_list_export3}${item2}:"
							done

							# Storing the "timeseries_file_list_export" variable content in a text file. No need to create this file empty, as it has no input from the user at this point (thus no possibility of keeping entries to it from previous loops)
							echo "${item1}:${timeseries_file_list_export3}" >> ${temp_folder}/timeseries_file_list_${SUBJ}_TEMP.txt

						elif [ ${item} = rest_ASL ]
						then
							# Variables for path to the files being processed
							timeseries_type_folder=rest
							timeseries_type_filename=resting

							image_type_contrast="RESTING ASL"
							modality_contrast=ASL

							# Collecting all timeries runs available for subject into a variable
							timeseries_file_list_temp4=`ls -d ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_type_filename}*_${modality_contrast}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/'!!'`

							# Looping to put all files in a single line separated by semicolon
							for item2 in ${timeseries_file_list_temp4}
							do
								timeseries_file_list_export4="${timeseries_file_list_export4}${item2}:"
							done

							# Storing the "timeseries_file_list_export" variable content in a text file. No need to create this file empty, as it has no input from the user at this point (thus no possibility of keeping entries to it from previous loops)
							echo "${item1}:${timeseries_file_list_export4}" >> ${temp_folder}/timeseries_file_list_${SUBJ}_TEMP.txt
						fi

						# Collecting all timeries runs available for subject into a variable
						timeseries_file_list_temp5="${timeseries_file_list_temp1} ${timeseries_file_list_temp2} ${timeseries_file_list_temp3} ${timeseries_file_list_temp4}"
					done

					# Giving feedback to the user
					echo -e "\n"
					echo -e "\tThese are the timeseries runs for subject ### ${SUBJ} ###: \n"

					# Establishing the initial timeseries type numbering
					count=1

					for item2 in ${timeseries_file_list_temp5}
					do
						# This is to add trailing zeros to this number, so instead of "2" you have "002" for example. Maybe needed if subject's listing gets mixed up due to numbers like "10" being listed before "2", e.g. 1 10 11 2 3 4
						counter=`printf "%02d" ${count}`

						# Note the use of "sed" to remove the folder name (appended to each filename) for presentation to user
						echo "${counter}) `echo ${item2} | sed -e 's!func/!!g; s!rest/!!g'`"

						# Adding a unit to the numbering variable
						((count++))
					done

					# Getting user input
					echo
					echo -en "Please enter the number for the functional run(s) to be processed for ${SUBJ} (if more than one separate with spaces, if you want ALL of them just enter \"all\"): "
					read timeseries_file_list_temp_user

					# Checking the user's input, and presenting them in a numbered list
					if [ -n "${timeseries_file_list_temp_user}" ] && [ "${timeseries_file_list_temp_user}" != all ] # Checking if this variable is non-zero in length and DOES NOT include the word "all"
					then
						# Establishing the initial timeseries type numbering
						counter=1

						# Collecting the timeseries run folders available into a variable to be used in the FUNCTION "NUMBERED_LIST" (functionslibr_FSL)
						var1_available=`for item in ${timeseries_file_list_temp5}; do echo "${counter}=${item}"; ((counter++)); done` # variable with all the files in a numbered list
						var2_list="${timeseries_file_list_temp_user}" # The numbers chosen by the user corresponding to the files to be used

						# Calling the function "numbered_list_display" to present the functional run folders available in a numbered list to the user. Note the parameters to be passed on to the function
						numbered_list_display "${var1_available}" "${var2_list}"

						# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
						timeseries_file_list_temp_user="${files_to_use}"

						# Cleaning the contents of the variables below
						unset files_to_use

					elif [ -n "${timeseries_file_list_temp_user}" ] && [ "${timeseries_file_list_temp_user}" = all ] # Checking if this variable is non-zero in length and DOES include the word "all"
					then
						timeseries_file_list_temp_user=${timeseries_file_list_temp3}
					fi

					echo -e "\nTimeseries runs entered:\n"

					# Establishing the initial timeseries type numbering
					count=1

					# Presenting the selected functional run folders to the user
					for item3 in ${timeseries_file_list_temp_user}
					do
						# This is to add trailing zeros to this number, so instead of "2" you have "002" for example. Maybe needed if subject's listing gets mixed up due to numbers like "10" being listed before "2", e.g. 1 10 11 2 3 4
						counter=`printf "%02d" ${count}`

						echo "${counter}) ${item3}"

						# Adding a unit to the numbering variable
						((count++))
					done

					echo
					echo -en "\nIs this correct? (y/n) "
					read conf

					# Check if the functional runs entered are correct
					if [ ${conf} = y ]
					then
						# Looping through the timeseries types as selected by user
						for item0 in ${timeseries_type_use}
						do
							# Looping through the timeseries files as selected by user
							for item1 in ${timeseries_file_list_temp_user}
							do
								# Getting the line specific for this timeseries type from the temporary file
								line=`grep ${item0}: ${temp_folder}/timeseries_file_list_${SUBJ}_TEMP.txt`

								# Removing the timeseries type from the "line" variable contents
								line=${line/${item0}/}

								# Changing the separating character from ":" to spaces
								line_clean=`echo $line | sed 's/:/ /g'`

								# Comparison to see which of the timeseries file(s) chosen by user for the type being processed are to included in the final text file
								for item2 in $line_clean
								do
									if [ "$item1" = "$item2" ] # In this case both items match
									then
										# Storing the item under comparison into a variable
										timeseries_files_selected="${timeseries_files_selected} $item2"
									fi
								done
							done

							# Exporting all the timeseries files selected by user to the final text file
							echo "${timeseries_files_selected}" >> ${temp_folder}/timeseries_file_list_${SUBJ}.txt

							# Cleaning the contents of the variable below
							unset timeseries_files_selected
						done

						break
					else
						echo
						echo -en "Please correct functional runs entered "

						sleep 2
					fi
				done
			else
				echo -e "\n"
				echo -e "*** No valid option chosen! ***\n"

				echo -en "Press any key to return to the PROCESSING menu "
				read -n1 anykey

				exit
			fi
		done

		# FUNCTION CALL: calling the function "options_user_input" to allow the user to choose the relevant options for fsl_motion_outliers. It will also create the ppss command file needed for the function "parallel_processing_ppss"
		options_user_input

		# FUNCTION CALL: calling the function "parallel_processing_ppss" to run the command. Note 2 parameters: 1) path to the folder holding the temporary files for this script; 2) the name of the files holding the commands for PPSS to run. Added a 3rd parameter to signal the function "parallel_processing_ppss" that the PPSS log files will be deleted there.
		# Not using the 4th parameter (list of unique identifiers for differentiating commands, e.g. a list of subjects), SO ALL SUBJECT'S FILES ARE PROCESSED IN A ROW, INSTEAD OF ON A SUBJECT-BY-SUBJECT BASIS (FASTER AND OPTIMIZED USE OF PPSS).
		parallel_processing_ppss ${temp_folder} ${ppss_command_file} ppss_function

		###### Listing the subjects processed ######
		# FUNCTION CALL: Calls the function "subjects_listed2process" in "mainscrcall_funclib" to list to the user all subjects processed and those not processed by the script invoking it
		subjects_listed2process
		################################################

		# Reminder to the user that he must run option 2 in this script afterwards, in order to generate the confound EV matrices
		echo
		echo -e "### Please remember that, in order to generate the confoundEV matrices with COMMON outliers detected from more than one metric to be used in FEAT processing, you must run option 2 of this script ###"

		echo -en "Press any key to continue to the PROCESSING menu "
		read -n1 anykey

		break
		;;
	2)
		clear

		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "motion_outliers:Generate outlier matrices" none "none"

		echo -e "\n"
		echo -e "*** Generating outlier matrices ***\n"

		##### 1st PRELIMINARY STEP - Getting from the user the metrics to generate the confound matrices #####
		# Requesting the user to choose the metrics in order to generate the confound outlier matrix
		while [ 1 ]
		do
			echo
			echo -e "These are the metrics available for \"fsl_motion_outliers\" output files:\n"

			# Making the metrics within the "metrics_available" variable to be listed in a numbered list for the user
			# Establishing tne initial subject numbering
			metric_number=1

			for metric in ${metrics_available}
			do
				echo "${metric_number}) ${metric}"

				# adding a unit to the numbering variable
				metric_number=$[ $metric_number + 1 ]
			done

			# Cleaning the contents of the numbering variable
			unset metric_number

			# FOR NOW IT CAN ONLY COMPARE 2 METRICS. IN THE FUTURE EXPAND THE CODE TO ACCEPT AS MANY METRICS AS ENTERED BY THE USER
			echo -en "\tPlease enter the number referring to 2 metrics to be used (Separate them using space; enter \"all\" for the whole list): "
			read metric_choose

			if [ -n "${metric_choose}" ] && [ "${metric_choose}" != all ] # Checking if this variable is non-zero in length and does NOT include all metrics listed
			then
				# Establishing the initial metric numbering
				metric_number=1

				# Collecting the metrics listed in the "metric_choose" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (functionslibr_FSL)
				var1_available=`for metric in ${metrics_available}; do echo "${metric_number}=${metric}"; metric_number=$[ $metric_number + 1 ]; done` # variable with all the files in a numbered list
				var2_list="${metric_choose}" # The numbers chosen by the user corresponding to the files to be used

				# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
				numbered_list_display "${var1_available}" "${var2_list}"

				# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
				metric_calculate="${files_to_use}"

				# Cleaning the contents of the variables below
				unset files_to_use
				unset metric_number

			elif [ -n "${metric_choose}" ] && [ "${metric_choose}" = all ] # Checking if this variable is non-zero in length and does include all metrics listed
			then
				metric_calculate="${metrics_available}"

			elif [ -z "${metric_choose}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
			then
				echo
				echo -e "*** No metric was choosen ***"
				echo -e "It will use all metrics available in this case (you can change this later, if needed)\n"

				metric_calculate="${metrics_available}"

				echo -en "Press any key to continue "
				read -n1 anykey
			fi

			# Showing to the user the option entered prior to processing
			echo -e "\n"
			echo -e "These are the metrics entered to generate the compound confound matrices:\n"

			# Making the metrics within the "metric_choose" variable to be listed in a numbered list for the user
			# Establishing tne initial metric numbering
			metric_number=1

			for metric in ${metric_calculate}
			do
				echo "${metric_number}) ${metric}"

				# Adding a unit to the numbering variable
				metric_number=$[ $metric_number + 1 ]
			done

			# Cleaning the contents of the numbering variable
			unset metric_number

			echo
			echo -en "Is this correct? (y/n) "
			read yesno

			if [ ${yesno} = y ] || [ ${yesno} = Y ]
			then
				# Going to the processing stage
				break

			elif [ ${yesno} = n ] || [ ${yesno} = N ]
			then
				echo -e "\n"
				echo -en "Please correct the metrics to be used "

				sleep 2

				# Cleaning the contents of the variable below
				unset metric_calculate
			fi
		done

		##### 2nd PRELIMINARY STEP - Checking the fsl_motion_outliers output files available for each subject's functional run #####
		# Loop to allow user to choose the timeseries type(s) to be processed
		while [ 1 ]
		do
			# FUNCTION CALL: Calling function "timeseries_selection" to select which timeseries types to be processed
			timeseries_selection

			echo -e "\n"
			echo -e "You entered the following:"
			echo -e "\tTime-Series types: ${timeseries_type_use}"

			echo
			echo -en "Is this correct? (y/n) "
			read yesno

			if [ ${yesno} = y ] || [ ${yesno} = Y ]
			then
				# Going to the processing stage
				break

			elif [ ${yesno} = n ] || [ ${yesno} = N ]
			then
				echo -e "\n"
				echo -en "Please correct the options entered "

				sleep 2

				# Cleaning the contents of the variable below
				unset timeseries_type_use
			fi
		done

		# First checking if there are outlier TR detection output files previously generated
		for SUBJ in ${SUBJLIST}
		do
			echo -e "\n"
			echo -e "#########################################################################################"
			echo -e "\tGenerating outlier TR matrix for all functional runs for subject \"${SUBJ}\""
			echo -e "#########################################################################################"

			# Variable to mark if at least ONE of the timeseries for this subject was processed by this loop
			subj_process_timeseries=0

			# Looping through each timeseries type
			for item1 in ${timeseries_type_use}
			do
				if [ ${item1} = func_BOLD ]
				then
					# Variables for path to the files being processed
					timeseries_type_folder=func
					timeseries_type_filename=frun

					image_type_contrast="FUNCTIONAL BOLD"
					modality_contrast=BOLD

				elif [ ${item1} = rest_BOLD ]
				then
					# Variables for path to the files being processed
					timeseries_type_folder=rest
					timeseries_type_filename=resting

					image_type_contrast="RESTING BOLD"
					modality_contrast=BOLD

				elif [ ${item1} = func_ASL ]
				then
					# Variables for path to the files being processed
					timeseries_type_folder=func
					timeseries_type_filename=frun

					image_type_contrast="FUNCTIONAL ASL"
					modality_contrast=ASL

				elif [ ${item1} = rest_ASL ]
				then
					# Variables for path to the files being processed
					timeseries_type_folder=rest
					timeseries_type_filename=resting

					image_type_contrast="RESTING ASL"
					modality_contrast=ASL
				fi

				# Using the -d option of ls will list directories contained in this folder, and not files. The sed function removes the path but preserves the folder name ("func" or "rest") as it is needed for the "options_user_input" function
				timeseries_file_list=`ls -d ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_type_filename}*_${modality_contrast}* | sed 's!'${SUBJS_FOLDERS_PATH}/${SUBJ}/'!!'`

				# Giving feedback to the user
				echo -e "\n"

				echo -en "These are the `echo ${image_type_contrast}` timeseries runs for subject ### ${SUBJ} ###:\n`echo ${timeseries_file_list} | sed 's!'${timeseries_type_folder}/'!!g'` "

				# Looping to put all files in a single line separated by semicolon
				for item2 in ${timeseries_file_list}
				do
					timeseries_file_list_export="${timeseries_file_list_export} ${item2}"
				done

				# Storing the "timeseries_file_list_export" variable content in a text file. No need to create this file empty, as it has no input from the user at this point (thus no possibility of keeping entries to it from previous loops)
				echo "${timeseries_file_list_export}" >> ${temp_folder}/timeseries_file_list_${SUBJ}.txt

				# Cleaning contents of variable below
				unset timeseries_file_list timeseries_file_list_export
			done

			for item in `cat ${temp_folder}/timeseries_file_list_${SUBJ}.txt`
			do
				###### Defining variables for folders #######
				# Timeseries type folder name
				timeseries_type_folder=`echo ${item} | awk -F/ '{print $1}'`
				# Run folder name (without "func/" or "rest/")
				timeseries_run_folder=`echo ${item} | awk -F/ '{print $2}'`
				#############################################

				# Entering the func folder for this subject
				cd ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}

				# Creating the temporary folders to be used in this script. Note the use of the "-p" parameter for mkdir to create parent folders as needed
				mkdir -p ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}

				# Determining the METRICS available for this functional run by listing PROCESSINFO files available for this folder. This is the marker that "fsl_motion_outliers" was run for a subject, as the confoundEV files may not be present even after "fsl_motion_outliers" if they have no outlier TRs
				ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/*_OUTLIERS_SINGLEMETRIC_*_processinfo.txt 2> /dev/null | awk 'BEGIN {FS="_"} { print ( $(NF-1) ) }' > ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outliers_metrics_${SUBJ}__${timeseries_run_folder}

				# Determining CONFOUNDEV files available for this func folder with their ABSOLUTE path
				ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/*_OUTLIERS_SINGLEMETRIC_*_confoundEV.txt 2> /dev/null > ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outliers_confoundEV_filelist_${SUBJ}__${timeseries_run_folder}

				# Determining PROCESSINFO files available for this folder with their ABSOLUTE path. This is the marker that "fsl_motion_outliers" was run for a subject, as the confoundEV files may not be present even after "fsl_motion_outliers" if they have no outlier TRs
				ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/*_OUTLIERS_SINGLEMETRIC_*_processinfo.txt 2> /dev/null > ${temp_folder}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/outliers_processinfo_filelist_${SUBJ}__${timeseries_run_folder}

				# Same as above but putting contents into a variable and taking off the spaces for testing if it has contents below.
				outliers_processinfo_filelist_nospaces=`ls ${SUBJS_FOLDERS_PATH}/${SUBJ}/${timeseries_type_folder}/${timeseries_run_folder}/QA_motion/fsl_motion_outliers_output/*_OUTLIERS_SINGLEMETRIC_*_processinfo.txt 2> /dev/null | tr "\n" "-"`

				cd /tmp

				# Checking if outlier TR detection was already ran (if so, its output files may or may not be available for later steps in this script - which the script can handle)
				if [ X${outliers_processinfo_filelist_nospaces} != X ]
				then
					# Calling the function "generate_outlier_TR_matrix" to generate the outlier TR matrix for FEAT processing
					generate_outlier_TR_matrix

					# Marking this subject as processed by using the variable "subj_process_timeseries"
					((subj_process_timeseries++))
				else
					echo -e "\n"
					echo -e "*** WARNING - Could not find outlier TR detection files for subject \"${SUBJ}\" ***"
					echo -e "These are needed for this script processing\n"

					echo -e "Please ran \"Motion outlier detection\" option in the PROCESSING menu before running the present script\n"

					echo -n "Press any key to skip processing this subject "
					read -n1 anykey
				fi

				# Cleaning the below variables content
				unset outliers_output_filelist
				unset outliers_output_filelist_nospaces
				unset outliers_output_filelist_temp
			done

			if [ ${subj_process_timeseries} -gt 0 ]
			then
				# In this case, at least one timeseries run was processed for this subject
				#### Gathering this subject into a variable for processing. This will be used by the function "subjects_processed" in mainscrcall_funclib #####
				subj_process="${subj_process} ${SUBJ}"
			else
				# Gathering the subjects that were skipped to a variable to later present it to the user
				subj_NOT_processed="${subj_NOT_processed} ${SUBJ}"
			fi
		done

		echo -e "\n"
		echo -e "Finished processing all subjects\n"

		###### Listing the subjects processed ######
		# FUNCTION CALL: Calls the function "subjects_listed2process" in "mainscrcall_funclib" to list to the user all subjects processed and those not processed by the script invoking it
		subjects_listed2process
		################################################

		echo
		echo -en "Press any key to continue to the PROCESSING menu "
		read -n1 anykey

		break
		;;
	*)
		echo
		echo -en "No valid option chosen - returning to previous menu "

		sleep 2

		clear
		;;
	esac
done

# Creating a log file. STEP 2 of 2 = finish call
# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 1 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. List of subjects processed
log_file_scripts_used finish "${SUBJLIST}"

# Removing temporary folders and files created
rm -r ${temp_folder} 2> /dev/null