#! /bin/bash

# Script to do distortion correction in DWI image files using fieldmaps throught FEAT pre-stats

# Sourcing of functions library files #
. mainscrcall_funclib

# Setting Ctrl + C as key combination to go back to PROCESSING menu. Also signals to the log file (=if there is one) that this script was interrupted
trap "echo -en '\n\nGoing back to the PROCESSING menu '; sleep 2; log_file_scripts_used interrupt; exit" SIGINT

# Checking if variables are not empty
emptvar=${MEDIA}
var_checked="THE MAIN FOLDER HOLDING MRI DATA"
checkemptvar

emptvar=${EXPERIMENT}
var_checked="THE EXPERIMENT NAME"
checkemptvar

emptvar="${SUBJLIST}"
var_checked="THE SUBJECT(S) TO BE PROCESSED"
checkemptvar

emptvar="${SUBJS_FOLDERS_PATH}"
var_checked="THE FOLDER CONTAINING ALL SUBJECTS' FOLDERS"
checkemptvar

# Checking if the folder for analysis was created
foldercheck=${MEDIA}/${EXPERIMENT}/${analysis_folder}
checkfoldexist2

##########			FUNCTIONS USED IN THIS SCRIPT			##########
function feat_template {
# This function will check if the "feat_templates" folder exists and if so, allow the user to choose the appropriate "design.fsf" file
while [ 1 ]
do
	echo -e "\n"
	echo -e "\tPlease check if you created your DWI unwarp FEAT pre-stats template and it is listed in here:"

	# Testing if "feat_templates is a valid folder
	if [ -d ${FULLPATH}/${feat_templates_folder} ]
	then
		echo
		ls ${FULLPATH}/${feat_templates_folder}/*.fsf | sed 's!'${FULLPATH}/${feat_templates_folder}/'!!' | sed "=" | sed 'N; s/\n/) /'

		# Here the user will choose the template file needed
		echo
		echo -en "Please enter the number corresponding to the .fsf template file of interest from the list above: "
		read feat_template_fullanalysis

		# Collecting the fsf files available into a variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
		var1_available=`ls ${FULLPATH}/${feat_templates_folder}/*.fsf | sed 's!'${FULLPATH}/${feat_templates_folder}/'!!' | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list
		var2_list="${feat_template_fullanalysis}" # The numbers chosen by the user corresponding to the files to be used

		# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
		numbered_list_display "${var1_available}" "${var2_list}"

		# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
		feat_template_fullanalysis=`echo ${files_to_use}` # Need to use echo here instead of just quotes around the variable "files_to_use" in order to eliminate the trailing spaces

		# Cleaning the contents of the variables below
		unset files_to_use

		# Checking if the file chosen above is a .fsf file
		# Assigning a variable with a file extension as output to check if the entered file above is a .fsf file
		fsf_file=`if echo ${FULLPATH}/${feat_templates_folder}/${feat_template_fullanalysis} | grep -q '.fsf'; then echo fsf; else echo wrong; fi`

		# Checking if the full_analysis_template file exists, and if its extension is "fsf"
		if [ -f ${FULLPATH}/${feat_templates_folder}/${feat_template_fullanalysis} ] && [ ${fsf_file} = fsf ]
		then
			echo -e "\n"
			echo -e "The template file ### ${feat_template_fullanalysis} ### exists and it is a .fsf file as needed"

			##### VARIABLE USED IN OTHER PARTS OF THE SCRIPT #####
			# This will create a variable to label the fsf file to be created later in this script
			FEAT_TEMPLATE_USED=`echo ${feat_template_fullanalysis} | sed 's/.fsf//'`

			echo -en "Press any key to continue "
			read -n1 anykey

			break
		else
			echo
			echo -en "DWI unwarp FEAT pre-stats template file entered does not exist or it is not a .fsf file - please check "

			sleep 2
		fi
	else
		echo
		echo -e "### There is no \"feat_templates\" folder ### here: ${FULLPATH}/${feat_templates_folder}"
		echo -e "Please check this and/or create this folder before proceeding\n"

		echo -en "Press any key to go back to PROCESSING MENU "
		read -n 1 anykey

		exit
	fi
done
}

function design_file_createcheck {
# This function will check if the subject being processed should have an individualized "design.fsf" file created
# Checking if this subject should have an individualized design file created
if [ ${proceed_design_file} = yes ]
then
	# Functional files list variable to be used in the "design_file_individualization" function
	dwifile_list_process="${dwifile_list_temp}"

	# FUNCTIONAL CALL: function "design_file_individualization" to create an individualized prestats design.fsf file
	design_file_individualization

	# Cleaning the contents of the variable below
	unset proceed_design_file

elif [ ${proceed_design_file} = no ]
then
	# Gathering the subjects that were skipped to a variable to later present it to the user
	subj_not_processed="${subj_not_processed} ${SUBJ}"

	# Cleaning the contents of the variable below
	unset proceed_design_file
fi
}

function design_file_individualization {
# This function will create the individualized file for the subject being processed
# Giving feedback to the user
echo -e "\n"
echo -e "Creating the individualized design.fsf file for subject ### ${SUBJ} ###\n"

###### VARIABLES IN THE "design.fsf" TEMPLATE THAT CAN BE SUBSTITUTED BY THIS SCRIPT #####
# "Path of output directory
# Line 36 set fmri(outputdir)

# Set number of functional runs to be processed
# Line 51 set fmri(multiple) 2

#### B0 unwarping options #####
# Perform B0 unwarping yes/no"
# Line 87 set fmri(regunwarp_yn) 0

# B0 unwarp input image for analysis 1
# set unwarp_files(1) "/Users/moanae/mri_testing/subjs/FM0001_20121203/func/fieldmap_BOLD_01/FM0001_20121203_fieldmap_BOLD_01_stdMNI_rads"

# B0 unwarp mag input image for analysis 1
# set unwarp_files_mag(1) "/Users/moanae/mri_testing/subjs/FM0001_20121203/func/fieldmap_BOLD_mag01/FM0001_20121203_fieldmap_BOLD_mag01_stdMNI_brain"
##############################

# Set path of functional run(s) to be processed
# Line 281 set feat_files(1)

# Set path of skull-striped anatomical file
# Line 281 set highres_files(1)
#############################################################################################


###### STARTS SUBSTITUTION OF TEMPLATE VARIABLES #####

# Creating the temporary fsf text file for the FEAT analysis
echo -e "\n\n\n############################################################" > ${temp_folder}/temp_individualized_full_analysis.fsf
echo -e "##### VARIABLES CREATED TO INDIVIDUALIZE THIS ANALYSIS #####" >> ${temp_folder}/temp_individualized_full_analysis.fsf
echo -e "############################################################" >> ${temp_folder}/temp_individualized_full_analysis.fsf

# Setting the variable holding the sed commands to delete the appropriate lines of the "design.fsf" template file
linedelete=""

##### NUMBER OF FUNCTIONAL RUNS #####
##### SET NUMBER OF FIRST LEVEL ANALYSES TO BE RUN (HOW MANY FUNCTIONAL RUNS) #####
# Variable to delete the relevant line in the "design.fsf" template file
linedelete="${linedelete} | sed '/^set fmri(multiple)/d'"

varW=1 # Using a variable in case need to modify how many processes to be used
numdwifile=""

numdwifile="\nset fmri(multiple) ${varW}\n"

##############################
# Exporting the variable to temporary text files to be later added to the final design.fsf file
echo -e ${numdwifile} > ${temp_folder}/tempnumdwifile
cat ${temp_folder}/tempnumdwifile >> ${temp_folder}/temp_individualized_full_analysis.fsf
##############################
###############################################################################

##### LOCATION OF EACH FUNCTIONAL RUN #####
##### SET A FEAT_FILE VARIABLE FOR THE LOCATION OF EACH FUNCTIONAL RUN ####
# Variable to delete the relevant line in the "design.fsf" template file
linedelete="${linedelete} | sed '/^set feat_files/d'"

varX=1 # Using a variable in case need to modify how many processes to be used
feat_FILES=""

feat_FILES=$feat_FILES"\nset feat_files(${varX}) \"${dwifile_fullpath}\"\n"

##############################
# Exporting the variable to temporary text files to be later added to the final design.fsf file
echo -e ${feat_FILES} > ${temp_folder}/tempdwifile
cat ${temp_folder}/tempdwifile >> ${temp_folder}/temp_individualized_full_analysis.fsf
##############################
###############################################################################

##### EPI distortion correction using FIELDMAP files #####
## CHECK IF FIELDMAP FILES ARE TO BE USED FOR EPI DISTORTION CORRECTION. IF YES, SET THE LOCATION OF THE FIELDMAP FILES (PHASE AND MAGNITUDE) FOR EACH FUNCTIONAL RUN -  ##
# Checking if user want to use confoundEV file for FEAT processing from the contents of variable "confoundEV_file_use"

# Variable to delete the relevant line in the "design.fsf" template file
linedelete="${linedelete} | sed '/^set fmri(regunwarp_yn)/d' | sed '/^set unwarp_files/d' | sed '/^set unwarp_files_mag/d'"

varB=0 # Has to use a variable, since it can be a value of "0" or "1" depending on having counfounding variables files to be used

###########################################################################
##### CHECKING HOW MANY FIELDMAP PHASE FILES EXISTS #####
# Collecting FIELDMAP phase file(s) for this subject's functional runs
fieldmap_phase_list=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_0?/${SUBJ}_fieldmap_${modality_process}_0?_stdMNI_rads.nii.gz 2> /dev/null`

# Checking if there is more than one FIELDMAP phase file. If yes, allows the user to choose the one to be used.
# Counting variable
count=0

for item in  ${fieldmap_phase_list}
do
	# Adding a unit for each file within the variable above
	((count++))
done

# Checking if the count variable is greater than one (indicating that there is more than one FIELDMAP phase file)
if [ ${count} -gt 1 ] # If positive, there is MORE than one FIELDMAP phase file
then
	# Giving feedback to the user
	echo -e "\n"
	echo -e "*** There is more than one FIELDMAP phase file for DWI runs ***"

	# Loop for user's input
	while [ 1 ]
	do
		echo
		echo -e "Please choose from the below files which to use:"

		# Establishing the initial subject numbering
		item_number=1

		for item in ${fieldmap_phase_list}
		do
			# This is to add trailing zeros to this number, so instead of "2" you have "02" for example
			item_number=`printf "%02d" ${item_number}`

			echo -e "\t${item_number}) `echo ${item} | awk -F/ '{print $NF}'`"

			# Adding a unit to the variable item_number
			((item_number++))
		done

		echo
		echo -en "\tPlease enter your option here: "
		read fieldmap_phase_file_user

		if [ -n "${fieldmap_phase_file_user}" ] # Checking if this variable is non-zero in length
		then
			# Establishing the initial numbering
			fieldmap_number=1

			# Collecting the metrics listed in the "fieldmap_phase_file_user" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
			var1_available=`for fieldmap in ${fieldmap_phase_list}; do echo "${fieldmap_number}=${fieldmap}"; ((fieldmap_number++)); done` # variable with all the files in a numbered list
			var2_list="${fieldmap_phase_file_user}" # The numbers chosen by the user corresponding to the files to be used

			# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
			numbered_list_display "${var1_available}" "${var2_list}"

			# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
			fieldmap_phase_file_user="${files_to_use}"

			# Cleaning the contents of the variables below
			unset files_to_use fieldmap_number

		elif [ -z "${fieldmap_phase_file_user}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
		then
			fieldmap_phase_file_user="None chosen!!"
		fi

		# Showing to the user the option entered prior to processing
		echo -e "\n"
		echo -e "This is the FIELDMAP phase file entered: `echo ${fieldmap_phase_file_user}  | awk -F/ '{print $NF}'`"

		echo
		echo -en "Is this correct? (y/n) "
		read yesno

		if [ ${yesno} = y ] || [ ${yesno} = Y ]
		then
			# Proceeding to collect the info for the FIELDMAP files
			##### FIELDMAP phase file #####
			fieldmap_phase_fileonly=${fieldmap_phase_file_user}

			##### FIELDMAP magnitude file #####
			# First, determining the folder number for the FIELDMAP phase file (the matching FIELDMAP magnitude folder will have the same number)
			fieldmapfolder_number=`echo ${fieldmap_phase_file_user} | awk -F/ '{print $NF}' | awk -F_ '{print $5}'`

			fieldmap_mag_fileonly=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_mag${fieldmapfolder_number}/${SUBJ}_fieldmap_${modality_process}_mag${fieldmapfolder_number}_stdMNI_brain.nii.gz 2> /dev/null`

			break

		elif [ ${yesno} = n ] || [ ${yesno} = N ]
		then
			echo -e "\n"
			echo -en "Please correct the metric to be used "

			sleep 2

			# Cleaning the contents of the variable below
			unset metric_calculate
		fi
	done

elif [ ${count} -eq 1 ] # If positive, there is ONLY ONE FIELDMAP phase file
then
	# Proceeding to collect the info for the FIELDMAP files
	##### FIELDMAP phase file #####
	fieldmap_phase_fileonly=${fieldmap_phase_list}

	##### FIELDMAP magnitude file #####
	fieldmap_mag_fileonly=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_mag*/${SUBJ}_fieldmap_${modality_process}_mag*_stdMNI_brain.nii.gz 2> /dev/null`
fi
###########################################################################

# Checking if these variables have content
if [ -n "${fieldmap_phase_fileonly}" ] && [ -n "${fieldmap_mag_fileonly}" ] # In this case, both have contents and EPI distortion correction will proceed
then
	# Adding a unit to the variable "varB"
	((varB++))

	# Setting the variable that signal for EPI distortion correction
	bzerounwarping="\nset fmri(regunwarp_yn) ${varB}\n"

	# Setting the variable for the FIELDMAP phase file with all details needed for the design.fsf file
	fieldmap_phase_filefull="\nset unwarp_files(${varB}) \"${fieldmap_phase_fileonly}\"\n"

	# Setting the variable for the FIELDMAP magnitude file with all details needed for the design.fsf file
	fieldmap_mag_filefull="\nset unwarp_files_mag(${varB}) \"${fieldmap_mag_fileonly}\"\n"
else
	echo
	echo -e "*** WARNING *** Could not find either the FIELDMAP phase or magnitude file(s) for subject \"${SUBJ}\""

	echo
	echo -e "You must check the reason before proceeding"
	echo -en "Press any key to continue, or Ctrl+c to abort "
	read -n 1 anykey
fi

##############################
# Exporting the variable to temporary text files to be later added to the final design.fsf file
echo -e ${bzerounwarping} > ${temp_folder}/tempbzerounwarping_yes
cat ${temp_folder}/tempbzerounwarping_yes >> ${temp_folder}/temp_individualized_full_analysis.fsf

echo -e ${fieldmap_phase_filefull} > ${temp_folder}/tempbzerounwarping_phase
cat ${temp_folder}/tempbzerounwarping_phase >> ${temp_folder}/temp_individualized_full_analysis.fsf

echo -e ${fieldmap_mag_filefull} > ${temp_folder}/tempbzerounwarping_mag
cat ${temp_folder}/tempbzerounwarping_mag >> ${temp_folder}/temp_individualized_full_analysis.fsf
##############################

##########################################################


##### ANATOMICAL FILE FOR REGISTRATION #####
##### PATH TO SKULL-STRIPPED ANATOMICAL FILE AND ASSIGNING IT TO EACH FUNCTIONAL RUN #####
# Variable to delete the relevant line(s) in the "design.fsf" template file
linedelete="${linedelete} | sed '/^set highres_files/d'"

varY=1 # Using a variable in case need to modify how many processes to be used
highres_FILES=""

highres_FILES="\nset highres_files(${varY}) \"${anatfile_fullpath}\""

echo -e ${highres_FILES} > ${temp_folder}/tempanatrun
cat ${temp_folder}/tempanatrun >> ${temp_folder}/temp_individualized_full_analysis.fsf
###############################################################################

##### OUTPUT DIR ####
##### SETTING THE PATH OF OUTPUT FOLDER AND NAME OF FEAT FOLDER. IT WILL HAVE THE SUBJECT NAME AND THE .FSF FILE NAME #####
# Variable to delete the relevant line(s) in the "design.fsf" template file
linedelete="${linedelete} | sed '/^set fmri(outputdir)/d'"

OUTPUT_folder="${dwifile_pathonly}/${FEAT_TEMPLATE_USED}"
echo -e "\nset fmri(outputdir) \"${OUTPUT_folder}\"" > ${temp_folder}/tempoutputdir
cat ${temp_folder}/tempoutputdir >> ${temp_folder}/temp_individualized_full_analysis.fsf
###############################################################################

###############################################################################
# 	Remove original entries in the "design.fsf" template file using a sed command (sed '/^pattern/d') that looks for a pattern than deletes the text line right after it.
## Note the use of the command "eval", as if it is not used bash does not accept the piping within the variable "linedelete", and gives out an error
eval cat ${FULLPATH}/${feat_templates_folder}/${feat_template_fullanalysis} "${linedelete}" > ${temp_folder}/temp_full_analysis.fsf
###############################################################################

###############################################################################
# Consolidating all variables added to an individualized *.fsf file for a particular subject
cat ${temp_folder}/temp_individualized_full_analysis.fsf >> ${temp_folder}/temp_full_analysis.fsf
mv ${temp_folder}/temp_full_analysis.fsf ${temp_folder}/${SUBJ}_${dwifile_nameonly}_${FEAT_TEMPLATE_USED}.fsf
###############################################################################

# Removing all temporary files
rm -f ${temp_folder}/temp*

cd /tmp
}

function distortion_correction_epireg {
# This function will proceed with distortion correction using the FSL tool _epi_reg"

# Checking if the subject has the DWI and ANATOMICAL files, as signaled by the variable "proceed_epireg_DWIanat"
if [ ${proceed_epireg_DWIanat} = yes ]
then
	###########################################################################
	##### CHECKING HOW MANY FIELDMAP PHASE FILES EXISTS #####
	# Collecting FIELDMAP phase file(s) for this subject's functional runs
	fieldmap_phase_list=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_0?/${SUBJ}_fieldmap_${modality_process}_0?_stdMNI_rads.nii.gz 2> /dev/null`

	# Checking if there is more than one FIELDMAP phase file. If yes, allows the user to choose the one to be used.
	# Counting variable
	count=0

	for item in  ${fieldmap_phase_list}
	do
		# Adding a unit for each file within the variable above
		((count++))
	done

	# Checking if the count variable is greater than one (indicating that there is more than one FIELDMAP phase file)
	if [ ${count} -gt 1 ] # If positive, there is MORE than one FIELDMAP phase file
	then
		# Giving feedback to the user
		echo -e "\n"
		echo -e "*** There is more than one FIELDMAP phase file for DWI runs ***"

		# Loop for user's input
		while [ 1 ]
		do
			echo
			echo -e "Please choose from the below files which to use:"

			# Establishing the initial subject numbering
			item_number=1

			for item in ${fieldmap_phase_list}
			do
				# This is to add trailing zeros to this number, so instead of "2" you have "02" for example
				item_number=`printf "%02d" ${item_number}`

				echo -e "\t${item_number}) `echo ${item} | awk -F/ '{print $NF}'`"

				# Adding a unit to the variable item_number
				((item_number++))
			done

			echo
			echo -en "\tPlease enter your option here: "
			read fieldmap_phase_file_user

			if [ -n "${fieldmap_phase_file_user}" ] # Checking if this variable is non-zero in length
			then
				# Establishing the initial numbering
				fieldmap_number=1

				# Collecting the metrics listed in the "fieldmap_phase_file_user" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
				var1_available=`for fieldmap in ${fieldmap_phase_list}; do echo "${fieldmap_number}=${fieldmap}"; ((fieldmap_number++)); done` # variable with all the files in a numbered list
				var2_list="${fieldmap_phase_file_user}" # The numbers chosen by the user corresponding to the files to be used

				# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
				numbered_list_display "${var1_available}" "${var2_list}"

				# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
				fieldmap_phase_file_user="${files_to_use}"

				# Cleaning the contents of the variables below
				unset files_to_use fieldmap_number

			elif [ -z "${fieldmap_phase_file_user}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
			then
				fieldmap_phase_file_user="None chosen!!"
			fi

			# Showing to the user the option entered prior to processing
			echo -e "\n"
			echo -e "This is the FIELDMAP phase file entered: `echo ${fieldmap_phase_file_user}  | awk -F/ '{print $NF}'`"

			echo
			echo -en "Is this correct? (y/n) "
			read yesno

			if [ ${yesno} = y ] || [ ${yesno} = Y ]
			then
				# Proceeding to collect the info for the FIELDMAP files
				##### FIELDMAP phase file #####
				fieldmap_phase_fileonly=`echo ${fieldmap_phase_file_user}`

				##### FIELDMAP magnitude file #####
				# First, determining the folder number for the FIELDMAP phase file (the matching FIELDMAP magnitude folder will have the same number)
				fieldmapfolder_number=`echo ${fieldmap_phase_file_user} | awk -F/ '{print $NF}' | awk -F_ '{print $5}'`

				# Fieldmap magnitude wholehead file
				fieldmap_mag_fileonly=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_mag${fieldmapfolder_number}/${SUBJ}_fieldmap_${modality_process}_mag${fieldmapfolder_number}_stdMNI.nii.gz 2> /dev/null`

				# Fieldmap magnitude brain file
				fieldmap_mag_brain_fileonly=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_mag${fieldmapfolder_number}/${SUBJ}_fieldmap_${modality_process}_mag${fieldmapfolder_number}_stdMNI_brain.nii.gz 2> /dev/null`

				break

			elif [ ${yesno} = n ] || [ ${yesno} = N ]
			then
				echo -e "\n"
				echo -en "Please correct the metric to be used "

				sleep 2

				# Cleaning the contents of the variable below
				unset metric_calculate
			fi
		done

	elif [ ${count} -eq 1 ] # If positive, there is ONLY ONE FIELDMAP phase file
	then
		# Proceeding to collect the info for the FIELDMAP files
		##### FIELDMAP phase file #####
		fieldmap_phase_fileonly=${fieldmap_phase_list}

		##### FIELDMAP magnitude file #####
		# Fieldmap magnitude wholehead file
		fieldmap_mag_fileonly=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_mag*/${SUBJ}_fieldmap_${modality_process}_mag*_stdMNI.nii.gz 2> /dev/null`

		# Fieldmap magnitude brain file
		fieldmap_mag_brain_fileonly=`ls ${dwi_mainfolder_path}/${SUBJ}/DWI/fieldmap_${modality_process}_mag*/${SUBJ}_fieldmap_${modality_process}_mag*_stdMNI_brain.nii.gz 2> /dev/null`
	fi
	###########################################################################

	# Checking if these variables have content
	if [ -z "${fieldmap_phase_fileonly}" ] && [ -z "${fieldmap_mag_fileonly}" ] # In this case, both have contents and EPI distortion correction will proceed
	then
		echo
		echo -e "*** WARNING *** Could not find either the FIELDMAP phase or magnitude file(s) for subject \"${SUBJ}\""

		echo
		echo -e "You must check the reason before proceeding"
		echo -en "Press any key to continue, or Ctrl+c to abort "
		read -n 1 anykey

		# Variable to allow or not creation of individualized design file
		proceed_epireg_fieldmap=no
	else
		# Variable to allow or not creation of individualized design file
		proceed_epireg_fieldmap=yes
	fi

	# Checking if should create the command to run "epi_reg" for this subject
	if [ ${proceed_epireg_fieldmap} = yes ]
	then
		#####################################
		# Issuing the command to create the output folder, then issuing the epi_reg command, and finally copying the undistorted file into the main DWI folder into a text file for parallel processing
		# Putting the full command into a variable
		command_processing=`echo -e "mkdir -p ${dwifile_pathonly}/${dwi_subject_subfolder}/unwarping_epireg 2> /dev/null; epi_reg --epi=${dwifile_fullpath} --t1=${anatfile_fullpath} --t1brain=${anatfile_brain_fullpath} --out=${dwifile_pathonly}/${dwi_subject_subfolder}/unwarping_epireg/data_DWI02_undistorted --fmap=${fieldmap_phase_fileonly} --fmapmag=${fieldmap_mag_fileonly} --fmapmagbrain=${fieldmap_mag_brain_fileonly} --echospacing=${echospacing} --pedir=${phaseencoding} --noclean &>  ${dwifile_pathonly}/${dwi_subject_subfolder}/unwarping_epireg/${SUBJ}_epireg_screenoutput.txt; cp ${dwifile_pathonly}/${dwi_subject_subfolder}/unwarping_epireg/data_DWI02_undistorted.nii.gz ${dwifile_pathonly}/${dwi_subject_subfolder}/"`
		
		# Adding the command to the ppss processing text file
		echo "${command_processing}" >> ${temp_folder}/${ppss_command_file}

		##### Creating a LOG file with the commands used for later QA if needed #####
		echo "OS name and version: ${os_nameandversion}; Command: epi_reg; FSL `cat $FSLDIR/etc/fslversion`; Date and time: `current_date_time 2`" > ${dwifile_pathonly}/${dwi_subject_subfolder}/LOGFILE_distortion-correction_epireg_${SUBJ}.txt

		echo -e "Command \"epi_reg\" to do distortion correction using fieldmaps" >> ${dwifile_pathonly}/${dwi_subject_subfolder}/LOGFILE_distortion-correction_epireg_${SUBJ}.txt

		echo -e "\n${command_processing}" >> ${dwifile_pathonly}/${dwi_subject_subfolder}/LOGFILE_distortion-correction_epireg_${SUBJ}.txt
		#####################################
	fi
fi
}

###########################################################################
###############			MAIN MENU ROUTINE			###############
###########################################################################

################ VARIABLES TO BE USED IN THIS SCRIPT #################
# Variable for the folder within "/tmp" for temporary files
temp_folder=/tmp/ppss_tempdir_dwi_preprocessing

# Variable with the basename for the file holding the commands for PPSS processing
ppss_command_file=dwi_preprocessing_list.txt

# Variable to hold the folder name for the template FEAT files
feat_templates_folder=templates_DWI-unwarp_feat_design-files

# Variable holding the type of image modality (Could hard code with "DWI", decided to keep the variable as is just in case)
modality_process=DWI

dwi_mainfolder_path=${SUBJS_FOLDERS_PATH} # Where the DWI files are. Can be modified by the user in this script.
dwi_subject_subfolder=DWI_42dirs_01 # To be used with "ls" command: The path to the subfolder within each subject's folder
######################################################################

clear

# Changing directory to /tmp in case the script comits some error - this will make any commands to be run within /tmp, preventing damage to the file system
cd /tmp

# Removing all temporary fsf templates and their temp folder within "/tmp" that might be present from previously aborted processing
rm -rf ${temp_folder} 2> /dev/null

# Creating the temp folder
mkdir ${temp_folder} 2> /dev/null

######### Script Main menu - Informing the user what this script does and asking for input #########
echo -e "Here you can process with distortion correction for DWI image files using fieldmaps using FEAT"
echo -e "Once FEAT is done, this script can then copy the corrected DWI image into the DWI main folder"

##### GATHERING THE PATH TO THE ANALYSIS FOLDER #####
# FUNCTION CALL: calls the function "analysis_mainfolder" in "mainscrcall_funclib" to allow the user to select the path to the subject's folders
analysis_mainfolder DWI

# Assigning the output variable from the function above to a local variable
dwi_mainfolder_path=${ANALYSIS_MAINFOLDER_PATH}
######################################################

echo
echo -e "Please choose what you want to do:"
echo -e "1. *** Distortion correction *** of DWI images using fieldmaps with FEAT"
echo -e "  1.1. *** Move *** distortion corrected DWI images from the FEAT folder into the main DWI folder"
echo -e "2. *** Distortion correction *** of DWI images using fieldmaps with \"epi_reg\""
echo -e "0. Back to main menu"

###### ADD A OPTION HERE TO DO DISTORTION CORRECTION USING THE FSL TOOL "epi_reg"

echo
echo -en "Enter your option here: "
read process_option

while [ 1 ]
do
	case ${process_option} in
	0)
		echo
		echo -en "Going back to the PROCESSING menu "
		sleep 2

		break
		;;
	1)
		# Giving instructions to the user
		echo -e "\n"
		echo -e "#####################################################"
		echo -e "############ DWI unwarping using FEAT ###############"
		echo -e "#####################################################"

		echo
		echo -e "This script will generate a \"design.fsf\" for each diffusion-weighted image file, for each subject, to do distortion correction using FEAT pre-stats processing"
		echo -e "Then run all FEAT processes in parallel by using PPSS or computing cluster"
		echo -e "*** All output will be located within the subject's main DWI folder ***"

		######################
		## Start processing ##
		######################
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "mainscrcall_funclib" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "mainscrcall_dwi_unwarp:Perform DWI distortion correction using FEAT" FSL "(main script) feat command line"

		# Giving feedback to the user
		echo -e "\n"
		echo -e "\tProcessing DWI distortion correction using FEAT for the following subjects:\n"

		# Making the subjects within the "SUBJLIST" variable to be listed in a numbered list for the user
		# Establishing the initial numbering
		count=1

		for SUBJ in ${SUBJLIST}
		do
			counter=`printf "%02d" ${count}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

			echo "${counter}) ${SUBJ}"

			# Adding a unit to the numbering variable
			((count++))
		done

		# Cleaning the contents of the numbering variable
		unset count counter

		# Routine to select the anatomical files to be processed and calling the function "design_file_individualization" to generate the individualized design.fsf file

		# FUNCTION CALL: Calling function "path_ANATfiles_processing" in "mainscrcall_funclib" to allow the user to enter the common path to the anatomical files for all subjects being processed
		path_ANATfiles_processing

		# Warning for the user to check if a full_analysis_template was created
		echo
		echo -e "*** You must have create a \"feat_templates\" folder that holds the *** DWI unwarping *** template. Please remember that the \"templates\" in the folder name is mandatory for the correct functioning of this program ***\n"

		echo -e "If you did not create yet the *** DWI unwarping *** template, press control+C to go back to main menu"
		echo -e "If you need to create the template, use the FEAT GUI to do so and remember to save the file inside the \"templates_DWI-unwarp_feat_design-files\" folder"
		echo -e "Also, since the template file name will be used to name the output FEAT folder you should name it with an informative name, e.g. \"DWIunwarping_minusY.fsf\""

		# Asking the user to concur to continue (so the user have time to read the warning above)
		echo
		echo -en "Press any key to continue "
		read -n 1 anykey

		##### Functions to prepare the processing of the "design.fsf" template file #####

		# FUNCTION CALL: Calling function "feat_template" to check if the "feat_templates" folder exists and if so, allow the user to choose the appropriate "design.fsf" file
		feat_template

		############################################################

		# Loop to go through each subject's DWI image file
		for SUBJ in ${SUBJLIST}
		do
			# Creating variables to be used in the full analysis script
			# functional files list variable
			echo -e "\n"
			echo -e "Checking the DWI image file and ANATOMICAL file to be processed for subject #### \"${SUBJ}\" ####"

			##### ROUTINE FOR AUTOMATIC COLLECTION OF ALL FUNCTIONAL RUNS AND ANATOMICAL FILE #####
			# Colecting info for the DWI files to be undistorted. NOTICE that it will look for the DWI already eddy current corrected by my scripts, which output a file named "data_DWI_edccorr.nii.gz"
			dwifile_list_temp=`ls -d1 ${dwi_mainfolder_path}/${SUBJ}/DWI/DWI_*/data_DWI01_edccorr.nii.gz`

			# Checking if there is more than one DWI file for the subject being processed. If yes, allows the user to choose the one to be used.
			# Counting variable
			count=0

			for item in  ${dwifile_list_temp}
			do
				# Adding a unit for each file within the variable above
				((count++))
			done

			# Checking if the count variable is greater than one (indicating that there is more than one DWI file)
			if [ ${count} -gt 1 ] # If positive, there is MORE than one DWI file
			then
				# Giving feedback to the user
				echo -e "\n"
				echo -e "*** There is more than one DWI file ***"

				# Loop for user's input
				while [ 1 ]
				do
					echo
					echo -e "Please choose from the below DWI files which to use:"

					# Establishing the initial subject numbering
					item_number=1

					for item in ${dwifile_list_temp}
					do
						# This is to add trailing zeros to this number, so instead of "2" you have "02" for example
						item_number=`printf "%02d" ${item_number}`

						echo -e "\t${item_number}) `echo ${item} | awk -F/ '{print $NF}'`"

						# Adding a unit to the variable item_number
						((item_number++))
					done

					echo
					echo -en "\tPlease enter your option here: "
					read dwifile_file_user

					if [ -n "${dwifile_file_user}" ] # Checking if this variable is non-zero in length
					then
						# Establishing the initial numbering
						dwifile_number=1

						# Collecting the metrics listed in the "dwifile_file_user" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
						var1_available=`for dwifile in ${dwifile_list}; do echo "${dwifile_number}=${dwifile}"; ((dwifile_number++)); done` # variable with all the files in a numbered list
						var2_list="${dwifile_file_user}" # The numbers chosen by the user corresponding to the files to be used

						# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
						numbered_list_display "${var1_available}" "${var2_list}"

						# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
						dwifile_file_user=`echo ${files_to_use}`

						# Cleaning the contents of the variables below
						unset files_to_use dwifile_number

					elif [ -z "${dwifile_file_user}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
					then
						dwifile_file_user="None chosen!!"
					fi

					# Showing to the user the option entered prior to processing
					echo -e "\n"
					echo -e "This is the DWI file entered: `echo ${dwifile_file_user}  | awk -F/ '{print $NF}'`"

					echo
					echo -en "Is this correct? (y/n) "
					read yesno

					if [ ${yesno} = y ] || [ ${yesno} = Y ]
					then
						# Proceeding to collect the info for the DWI files
						##### DWI file #####
						dwifile_fullpath=${dwifile_file_user}
						dwifile_nameonly=`echo ${dwifile_fullpath} | awk -F/ '{print $NF}' | sed 's/.nii.gz//'`
						dwifile_pathonly=${dwi_mainfolder_path}/${SUBJ}/DWI

						break

					elif [ ${yesno} = n ] || [ ${yesno} = N ]
					then
						echo -e "\n"
						echo -en "Please correct the DWI file to be used "

						sleep 2

						# Cleaning the contents of the variable below
						unset dwifile_file_user
					fi
				done

			elif [ ${count} -eq 1 ] # If positive, there is ONLY ONE FIELDMAP phase file
			then
				# Proceeding to collect the info for the DWI files
				##### DWI file #####
				dwifile_fullpath=`echo ${dwifile_list_temp}`
				dwifile_nameonly=`echo ${dwifile_fullpath} | awk -F/ '{print $NF}' | sed 's/.nii.gz//'`
				dwifile_pathonly=${dwi_mainfolder_path}/${SUBJ}/DWI
			fi

			# Checking if the anatomical file to be used has a different path than the subject's "anat" folder
			if [ ${fslanat_output_path} = none ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz`
				anatfile_nameonly=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz | awk -F/ '{print $NF}'`

			elif [ ${fslanat_output_path} = subj_anat_folder ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz`
				anatfile_nameonly=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz | awk -F/ '{print $NF}'`

			elif [ ${fslanat_output_path} = separate_folder ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr_brain.nii.gz`
				anatfile_nameonly=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr_brain.nii.gz | awk -F/ '{print $NF}'`
			fi

			if [ -n "${dwifile_fullpath}" ] && [ -f ${anatfile_fullpath} ] # Has to satisfy both conditions: 1) that the variable "dwifile_list_temp" has contents, and 2) That the ANATOMICAL image is a file within the above path
			then
				echo -e "\n"
				echo -e "\tDWI file available for ### ${SUBJ} ###: `echo ${dwifile_nameonly}`"

				echo
				echo -en "\tANATOMICAL file to be used for ### ${SUBJ} ###: ${anatfile_nameonly} "

				# Just so the user have a second to read it
				sleep 1

				# Variable to allow or not creation of individualized design file
				proceed_design_file=yes
			else
				echo
				echo -e "\tSkipping subject \"${SUBJ}\" as either no DWI file OR skull-stripped ANATOMICAL file was found"

				# Variable to allow or not creation of individualized design file
				proceed_design_file=no

				# Asking the user to allow to continue
				echo
				echo -en "Press any key to continue "
				read -n 1 anykey
			fi

			# FUNCTIONAL CALL: function "design_file_createcheck" to check if the subject being processed should have an individualized "design.fsf" file created files to be processed
			design_file_createcheck
		done

		# Presenting to the user the subjects to be processed, and the ones excluded due to lack of functional runs and/or anatomical file
		echo -e "\n\n"
		echo -e "The subjects listed below are going to be processed\n"

		# Establishing the initial subject numbering
		item_number=1

		for item in ${SUBJLIST}
		do
			item_number=`printf "%02d" ${item_number}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

			echo "${item_number}) $item"

			# Adding a unit to the variable item_number.
			# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
			item_number=$[10#$item_number + 1 ]
		done

		# Loop to check if subjects are not going to be processed
		if [ -n "${subj_not_processed}" ]
		then
			echo -e "\n"
			echo -e "Subjects NOT being processed due to no functional runs or anatomical file are listed below\n"

			# Establishing the initial subject numbering
			item_number=1

			for item in ${subj_not_processed}
			do
				item_number=`printf "%02d" ${item_number}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

				echo "${item_number}) $item"

				# Adding a unit to the variable item_number
				item_number=$[10#$item_number + 1 ]
			done
		fi

		################ ENTER A ROUTINE HERE TO COUNT HOW MANY ITEMS ARE TO  BE PROCESSED #############

		echo
		echo -en "Press any key to proceed with fieldmap distortion correction using FEAT for the subjects listed above "
		read anykey

		# This will use the fsf templates above in Feat to do the full analysis processing
		echo -e "\n"
		echo -e "### Starting distortion correction for all subjects entered ###"

		# Consolidating all subjects to be processed in a list within the PPSS file
		# for item in `ls ${temp_folder}/*_${FEAT_TEMPLATE_USED}.fsf`
		for item in `ls ${temp_folder}/*.fsf`
		do
			echo "feat ${item}" >> ${temp_folder}/${ppss_command_file}
		done

		# Calling the function "parallel_processing_ppss" (mainscrcall_funclib) to run FEAT command. Note 4 parameters: 1) path to the folder holding the temporary files for this script; 2) the name of the files holding the commands for PPSS to run; 3) parameter to indicate that the PPSS log files should be deleted by the function 4) list of unique identifiers for differentiating commands, e.g. a list of subjects. NOT USING THE 4th PARAMETER, SO ALL SUBJECT'S FILES ARE PROCESSED IN A ROW, INSTEAD OF ON A SUBJECT-BY-SUBJECT BASIS (FASTER AND OPTIMIZED USE OF PPSS)
		parallel_processing_ppss ${temp_folder} ${ppss_command_file} ppss_function

		break
		;;
	1.1)
		# Copying and renaming the output file from DWI unwarping
		# Giving feedback to the user
		echo
		echo -e "Copying the distortion corrected DWI image file to the main DWI folder and renaming it \"data_DWI02_undistorted.nii.gz\""

		for SUBJ in ${SUBJLIST}
		do
			# Giving feedback to the user
			echo
			echo -en "Processing subject *** ${SUBJ} *** "

			# Checking if there is an "DWIunwarping" folder for the subject being processed
			dwi_unwarp_folder_list=`ls -d ${dwi_mainfolder_path}/${SUBJ}/DWI/DWIunwarping*.feat`

			if [ -n "${dwi_unwarp_folder_list}" ] # Checking if this variable is not empty
			then
				# Checking if there is more than one "DWIunwarping" folder. If yes, warns the user.
				# Counting variable
				count=0

				for item in  ${dwi_unwarp_folder_list}
				do
					# Adding a unit for each file within the variable above
					((count++))
				done

				# Checking if the count variable is greater than one (indicating that there is more than one DWIunwarping FEAT folder)
				if [ ${count} -gt 1 ] # If positive, there is MORE than one FIELDMAP phase file
				then
					# Giving feedback to the user
					echo -e "\n"
					echo -e "*** There is more than one \"DWIunwarping\" folder for subject ${SUBJ} ***"

					echo
					echo -e "Please check the one that is valid (there can only be one)"

					# Loop for user's input
					while [ 1 ]
					do
						echo
						echo -e "Please choose from the below DWIunwarping FEAT folders which to use:"

						# Establishing the initial subject numbering
						item_number=1

						for item in ${dwi_unwarp_folder_list}
						do
							# This is to add trailing zeros to this number, so instead of "2" you have "02" for example
							item_number=`printf "%02d" ${item_number}`

							echo -e "\t${item_number}) `echo ${item} | awk -F/ '{print $NF}'`"

							# Adding a unit to the variable item_number
							((item_number++))
						done

						echo
						echo -en "\tPlease enter your option here: "
						read dwiunwarp_folder_user

						if [ -n "${dwiunwarp_folder_user}" ] # Checking if this variable is non-zero in length
						then
							# Establishing the initial numbering
							dwiunwarp_folder_number=1

							# Collecting the metrics listed in the "dwiunwarp_folder_user" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
							var1_available=`for dwiuwarp_folder in ${dwi_unwarp_folder_list}; do echo "${dwiunwarp_folder_number}=${dwiuwarp_folder}"; ((dwiunwarp_folder_number++)); done` # variable with all the files in a numbered list
							var2_list="${dwiunwarp_folder_user}" # The numbers chosen by the user corresponding to the files to be used

							# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
							numbered_list_display "${var1_available}" "${var2_list}"

							# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
							dwiunwarp_folder_user="${files_to_use}"

							# Cleaning the contents of the variables below
							unset files_to_use dwiunwarp_folder_number

						elif [ -z "${dwiunwarp_folder_user}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
						then
							dwiunwarp_folder_user="None chosen!!"
						fi

						# Showing to the user the option entered prior to processing
						echo -e "\n"
						echo -e "This is the DWI file entered: `echo ${dwiunwarp_folder_user}  | awk -F/ '{print $NF}'`"

						echo
						echo -en "Is this correct? (y/n) "
						read yesno

						if [ ${yesno} = y ] || [ ${yesno} = Y ]
						then
							# Proceeding to collect the info for the DWI files
							##### DWIunwarp folder #####
							dwi_unwarp_folder=${dwiunwarp_folder_user}
							############################

							# Copying the DWI distortion corrected file to the DWI main folder and renaming it
							cp ${dwi_unwarp_folder}/filtered_func_data.nii.gz ${dwi_mainfolder_path}/${SUBJ}/DWI/DWI_42dirs_01/data_DWI02_undistorted.nii.gz

							break

						elif [ ${yesno} = n ] || [ ${yesno} = N ]
						then
							echo -e "\n"
							echo -en "Please correct the DWI file to be used "

							sleep 2

							# Cleaning the contents of the variable below
							unset dwiunwarp_folder_user
						fi
					done


				elif [ ${count} -eq 1 ] # If positive, there is only one DWIunwarping FEAT folder
				then
					# NEED TO WRITE A ROUTINE TO CHECK IF THE SUBJECT HAS MORE THAN ONE "DWI_XXdirs_0X" FOLDER. RIGHT NOW IS HARD CODED FOR "DWI_42dirs_01"

					# Proceeding to collect the info for the dwi files
					##### dwiunwarp folder #####
					dwi_unwarp_folder=${dwi_unwarp_folder_list}
					############################

					# Copying the DWI distortion corrected file to the DWI main folder and renaming it
					cp ${dwi_unwarp_folder}/filtered_func_data.nii.gz ${dwi_mainfolder_path}/${SUBJ}/DWI/DWI_42dirs_01/data_DWI02_undistorted.nii.gz
				else
					# Giving feedback to the user
					echo -e "\n"
					echo -e "*** Could not find a \"DWIunwarping\" folder for subject ${SUBJ} ***"

					echo
					echo -e "Please check the reason for it (there must be at least one)"

					echo
					echo -en "Press any key to continue, or Ctrl+C to exit to the Processing menu "
					read -n 1 anykey
				fi

			else
				echo
				echo -e "*** WARNING *** subject ${SUBJ} does not have a \"DWIunwarping\" within its main DWI folder"
				echo -e "Please check this and proceed with running fieldmap distortion correction BEFORE trying again"

				echo
				echo -en "Press any key to continue, or Ctrl+C to exit to the Processing menu "
				read -n 1 anykey
			fi
		done

		echo -e "\n"
		echo -e "Copied and renamed the DWI distortion corrected image into the subjects main DWI folder"

		echo
		echo -en "Press any key to continue to the PROCESSING menu "
		read -n 1 anykey

		break
		;;
	2)
		# Giving instructions to the user
		echo -e "\n"
		echo -e "########################################################"
		echo -e "############ DWI unwarping using epi_reg ###############"
		echo -e "########################################################"

		echo
		echo -e "This script will do distortion correction using the FSL tool \"epi_reg\""
		echo -e "Then will run it in parallel by using PPSS or computing cluster"
		echo -e "*** It will automatically name the output \"data_DWI02_undistorted.nii.gz\" ***"

		######################
		## Start processing ##
		######################
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "mainscrcall_funclib" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "mainscrcall_dwi_unwarp:Perform DWI distortion correction using epi_reg" FSL "(main script) epi_reg command line"

		# Giving feedback to the user
		echo -e "\n"
		echo -e "\tProcessing DWI distortion correction using \"epi_reg\" for the following subjects:\n"

		# Making the subjects within the "SUBJLIST" variable to be listed in a numbered list for the user
		# Establishing the initial numbering
		count=1

		for SUBJ in ${SUBJLIST}
		do
			counter=`printf "%02d" ${count}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

			echo "${counter}) ${SUBJ}"

			# Adding a unit to the numbering variable
			((count++))
		done

		# Cleaning the contents of the numbering variable
		unset count counter

		# Routine to select the anatomical files to be processed and calling the function "design_file_individualization" to generate the individualized design.fsf file

		# FUNCTION CALL: Calling function "path_ANATfiles_processing" in "mainscrcall_funclib" to allow the user to enter the common path to the anatomical files for all subjects being processed
		path_ANATfiles_processing

		##### INFORMATION NEEDED FOR epi_reg PROCESSING #####
		# Getting the needed information from the user
		while [ 1 ]
		do
			echo -e "\n"
			echo -e "*** Several parameters are need to proceed with distortion correction using \"epi_reg\" ***"

			echo
			echo -e "1. Effective EPI echo spacing (=dwell time) for DWI image"
			echo -e "*** Note that if parallel acceleration is used in the EPI acquisition then the *effective* echo spacing is the actual echo spacing between acquired lines in k-space divided by the acceleration factor. ***"
			echo -en "Enter here the EPI echo spacing (in ms): "
			read echospacing_user

			echo
			echo -e "2. Phase encoding direction"
			echo -en "Enter here the the axis and direction for phase encoding (dir = x/y/z/-x/-y/-z): "
			read phaseencoding_user

			# Confirming the information entered
			echo -e "\n"
			echo -e "This is the information entered:"
			echo -e "EPI echo spacing (ms) = ${echospacing_user}"
			echo -e "Phase encoding direction = ${phaseencoding_user}"

			echo
			echo -en "Is this correct? (y/n) "
			read yesno

			if [ -n "${yesno}" ] && [ ${yesno} = y ]
			then
				####################################
				# Creating the processing variables
				# Transforming the units of echo spacing from ms to seconds, as needed for epi_reg
				echospacing=`echo "scale=5; ${echospacing_user} / 1000" | bc`
				phaseencoding=${phaseencoding_user}
				####################################

				break
			else
				echo
				echo -en "Please correct the information entered "

				sleep 2
			fi
		done
		############################################################

		# Loop to go through each subject's DWI image file
		for SUBJ in ${SUBJLIST}
		do
			# Creating variables to be used in the full analysis script
			# functional files list variable
			echo -e "\n"
			echo -e "Checking the DWI image file and ANATOMICAL file to be processed for subject #### \"${SUBJ}\" ####"

			##### ROUTINE FOR AUTOMATIC COLLECTION OF ALL FUNCTIONAL RUNS AND ANATOMICAL FILE #####
			# Colecting info for the DWI files to be undistorted. NOTICE that it will look for the DWI already eddy current corrected by my scripts, which output a file named "data_DWI_edccorr.nii.gz"
			dwifile_list_temp=`ls -d1 ${dwi_mainfolder_path}/${SUBJ}/DWI/DWI_*/data_DWI01_edccorr.nii.gz`

			# Checking if there is more than one DWI file for the subject being processed. If yes, allows the user to choose the one to be used.
			# Counting variable
			count=0

			for item in  ${dwifile_list_temp}
			do
				# Adding a unit for each file within the variable above
				((count++))
			done

			# Checking if the count variable is greater than one (indicating that there is more than one DWI file)
			if [ ${count} -gt 1 ] # If positive, there is MORE than one DWI file
			then
				# Giving feedback to the user
				echo -e "\n"
				echo -e "*** There is more than one DWI file ***"

				# Loop for user's input
				while [ 1 ]
				do
					echo
					echo -e "Please choose from the below DWI files which to use:"

					# Establishing the initial subject numbering
					item_number=1

					for item in ${dwifile_list_temp}
					do
						# This is to add trailing zeros to this number, so instead of "2" you have "02" for example
						item_number=`printf "%02d" ${item_number}`

						echo -e "\t${item_number}) `echo ${item} | awk -F/ '{print $NF}'`"

						# Adding a unit to the variable item_number
						((item_number++))
					done

					echo
					echo -en "\tPlease enter your option here: "
					read dwifile_file_user

					if [ -n "${dwifile_file_user}" ] # Checking if this variable is non-zero in length
					then
						# Establishing the initial numbering
						dwifile_number=1

						# Collecting the metrics listed in the "dwifile_file_user" variable into another variable to be used in the FUNCTION "NUMBERED_LIST" (mainscrcall_funclib)
						var1_available=`for dwifile in ${dwifile_list}; do echo "${dwifile_number}=${dwifile}"; ((dwifile_number++)); done` # variable with all the files in a numbered list
						var2_list="${dwifile_file_user}" # The numbers chosen by the user corresponding to the files to be used

						# Calling the function "numbered_list_display" to present the anatomical files available in a numbered list to the user. Note the parameters to be passed on to the function
						numbered_list_display "${var1_available}" "${var2_list}"

						# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
						dwifile_file_user=`echo ${files_to_use}`

						# Cleaning the contents of the variables below
						unset files_to_use dwifile_number

					elif [ -z "${dwifile_file_user}" ] # Checking if this variable is zero in length. In this case, it will use the default metric
					then
						dwifile_file_user="None chosen!!"
					fi

					# Showing to the user the option entered prior to processing
					echo -e "\n"
					echo -e "This is the DWI file entered: `echo ${dwifile_file_user}  | awk -F/ '{print $NF}'`"

					echo
					echo -en "Is this correct? (y/n) "
					read yesno

					if [ ${yesno} = y ] || [ ${yesno} = Y ]
					then
						# Proceeding to collect the info for the DWI files
						##### DWI file #####
						dwifile_fullpath=`echo ${dwifile_file_user}`

						dwifile_nameonly=`echo ${dwifile_fullpath} | awk -F/ '{print $NF}' | sed 's/.nii.gz//'`
						dwifile_pathonly=${dwi_mainfolder_path}/${SUBJ}/DWI

						break

					elif [ ${yesno} = n ] || [ ${yesno} = N ]
					then
						echo -e "\n"
						echo -en "Please correct the DWI file to be used "

						sleep 2

						# Cleaning the contents of the variable below
						unset dwifile_file_user
					fi
				done

			elif [ ${count} -eq 1 ] # If positive, there is ONLY ONE FIELDMAP phase file
			then
				# Proceeding to collect the info for the DWI files
				##### DWI file #####
				dwifile_fullpath=${dwifile_list_temp}
				dwifile_nameonly=`echo ${dwifile_fullpath} | awk -F/ '{print $NF}' | sed 's/.nii.gz//'`
				dwifile_pathonly=${dwi_mainfolder_path}/${SUBJ}/DWI
			fi

			# Checking if the ANATOMICAL file to be used has a different path than the subject's "anat" folder
			if [ ${fslanat_output_path} = none ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_stdMNI.nii.gz`
				anatfile_brain_fullpath=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_brain.nii.gz`
				anatfile_nameonly=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/${SUBJ}*T1*_stdMNI.nii.gz | awk -F/ '{print $NF}'`

			elif [ ${fslanat_output_path} = subj_anat_folder ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/T1_biascorr.nii.gz`
				anatfile_brain_fullpath=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/T1_biascorr_brain.nii.gz`
				anatfile_nameonly=`ls ${dwi_mainfolder_path}/${SUBJ}/${anat_file_folder}/T1_biascorr.nii.gz | awk -F/ '{print $NF}'`

			elif [ ${fslanat_output_path} = separate_folder ]
			then
				# Colecting info for the ANATOMICAL file for full analysis
				anatfile_fullpath=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr.nii.gz`
				anatfile_brain_fullpath=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr_brain.nii.gz`
				anatfile_nameonly=`ls ${anat_file_folder}/${SUBJ}*T1*.anat/T1_biascorr.nii.gz | awk -F/ '{print $NF}'`
			fi

			if [ -n "${dwifile_fullpath}" ] && [ -f ${anatfile_fullpath} ] # Has to satisfy both conditions: 1) that the variable "dwifile_list_temp" has contents, and 2) That the ANATOMICAL image is a file within the above path
			then
				echo -e "\n"
				echo -e "\tDWI file available for ### ${SUBJ} ###: `echo ${dwifile_nameonly}`"

				echo
				echo -en "\tANATOMICAL file to be used for ### ${SUBJ} ###: ${anatfile_nameonly} "

				# Just so the user have a second to read it
				sleep 1

				# Variable to allow or not creation of individualized design file
				proceed_epireg_DWIanat=yes
			else
				echo
				echo -e "\tSkipping subject \"${SUBJ}\" as either no DWI file OR skull-stripped ANATOMICAL file was found"

				# Variable to allow or not creation of individualized design file
				proceed_epireg_DWIanat=no

				# Gathering the subjects that were skipped to a variable to later present it to the user
				subj_not_processed="${subj_not_processed} ${SUBJ}"

				# Asking the user to allow to continue
				echo
				echo -en "Press any key to continue "
				read -n 1 anykey
			fi

			# FUNCTIONAL CALL: function "distortion_correction_epireg" to proceed with distortion correction using the FSL tool _epi_reg"
			distortion_correction_epireg
		done

		# Presenting to the user the subjects to be processed, and the ones excluded due to lack of functional runs and/or anatomical file
		echo -e "\n\n"
		echo -e "The subjects listed below are going to be processed\n"

		# Establishing the initial subject numbering
		item_number=1

		for item in ${SUBJLIST}
		do
			item_number=`printf "%02d" ${item_number}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

			echo "${item_number}) $item"

			# Adding a unit to the variable item_number.
			# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
			item_number=$[10#$item_number + 1 ]
		done

		# Loop to check if subjects are not going to be processed
		if [ -n "${subj_not_processed}" ]
		then
			echo -e "\n"
			echo -e "Subjects NOT being processed due to no functional runs or anatomical file are listed below\n"

			# Establishing the initial subject numbering
			item_number=1

			for item in ${subj_not_processed}
			do
				item_number=`printf "%02d" ${item_number}` # This is to add trailing zeros to this number, so instead of "2" you have "02" for example

				echo "${item_number}) $item"

				# Adding a unit to the variable item_number
				item_number=$[10#$item_number + 1 ]
			done
		fi

		################ ENTER A ROUTINE HERE TO COUNT HOW MANY ITEMS ARE TO  BE PROCESSED #############

		echo
		echo -en "Press any key to proceed with fieldmap distortion correction using \"epi_reg\" for the subjects listed above "
		read anykey

		# This will use the fsf templates above in Feat to do the full analysis processing
		echo -e "\n"
		echo -e "### Starting distortion correction for all subjects entered ###"

		# Calling the function "parallel_processing_ppss" (mainscrcall_funclib) to run FEAT command. Note 4 parameters: 1) path to the folder holding the temporary files for this script; 2) the name of the files holding the commands for PPSS to run; 3) parameter to indicate that the PPSS log files should be deleted by the function 4) list of unique identifiers for differentiating commands, e.g. a list of subjects. NOT USING THE 4th PARAMETER, SO ALL SUBJECT'S FILES ARE PROCESSED IN A ROW, INSTEAD OF ON A SUBJECT-BY-SUBJECT BASIS (FASTER AND OPTIMIZED USE OF PPSS)
		parallel_processing_ppss ${temp_folder} ${ppss_command_file} ppss_function

		break
		;;
	*)
		echo -e "No valid option chosen"
		echo -en "Please re-enter an option "

		sleep 2
		;;
	esac
done

# Creating a log file. STEP 2 of 2 = finish call
# Calling the function "log_file_scripts_used" in "mainscrcall_funclib" to output the characteristics of this script. It uses 1 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. List of subjects processed
log_file_scripts_used finish "${SUBJLIST}"

# Removing all temporary fsf templates and their temp folder within "/tmp" that might be present from previously aborted processing
rm -rf ${temp_folder} 2> /dev/null