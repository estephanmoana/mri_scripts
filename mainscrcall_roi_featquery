#! /bin/bash

# This script will use FEATQUERY on FEAT analysis at lower- and higher level analysis to extract ROI statistics

# Sourcing of functions library files #
. mainscrcall_funclib

# Setting Ctrl + C as key combination to go back to PROCESSING menu. Also signals to the log file (=if there is one) that this script was interrupted
trap "echo -en '\n\nGoing back to the PROCESSING menu '; sleep 2; log_file_scripts_used interrupt; exit" SIGINT

# Checking if variables are not empty
emptvar=${MEDIA}
var_checked="THE MAIN FOLDER HOLDING MRI DATA"
checkemptvar

emptvar=${EXPERIMENT}
var_checked="THE EXPERIMENT NAME"
checkemptvar

# emptvar="${SUBJLIST}"
# var_checked="THE SUBJECT(S) TO BE PROCESSED"
# checkemptvar
#
# emptvar="${SUBJS_FOLDERS_PATH}"
# var_checked="THE FOLDER CONTAINING ALL SUBJECTS' FOLDERS"
# checkemptvar

######################################################################
##########		FUNCTIONS USED IN THIS SCRIPT			##########
######################################################################

function choose_feat_folders {
# This function will ask the user which FEAT folders to be interrogated by FEATQUERY

# Loop for user to enter and check the FEAT FOLDERS TO BE INTERROGATED
while [ 1 ]
do
	echo -e "\n"
	echo -e "These are the contents of the analysis folder chosen: ${FULLPATH}/${analysis_level}\n"

	# Using the "-x" parameter for "ls" command so the entries are listed per line instead of per column
	## Also, it seems that the FEAT higher-level analysis creates only a "cope1.feat" subfolder according to my experience so far (June 28, 2011). If this assumption is wrong, this line will have to be changed to accomodate other "copeX.feat" folders
	ls -xd ${FULLPATH}/${analysis_level}/*.gfeat/cope1.feat | sed "s!${FULLPATH}/${analysis_level}/!!" | sed "s/.gfeat//" | sed "s!/cope1.feat!!" | sed "=" | sed 'N; s/\n/) /'

	echo
	echo -en "Please enter the number of the GFEAT folders listed above which are to be interrogated, separated by a space (if you want ALL of them, just enter \"all\"): "
	read folders_chosen

	# Checking if all GFEAT folders must be processed or just selected ones
	if [ "${folders_chosen}" = all ]
	then
		folders_chosen=`ls -xd ${FULLPATH}/${analysis_level}/*.gfeat/cope1.feat | sed "s!${FULLPATH}/${analysis_level}/!!" | sed "s/.gfeat//" | sed "s!/cope1.feat!!"`
	else
		# Collecting the GFEAT folders available into a variable to be used in the FUNCTION "NUMBERED_LIST" (functionslibr_FSL)
		var1_available=`ls -xd ${FULLPATH}/${analysis_level}/*.gfeat/cope1.feat | sed "s!${FULLPATH}/${analysis_level}/!!" | sed "s/.gfeat//" | sed "s!/cope1.feat!!" | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list
		var2_list="${folders_chosen}" # The numbers chosen by the user corresponding to the files to be used

		# Calling the function "numbered_list_display" to present the GFEAT folders available in a numbered list to the user. Note the parameters to be passed on to the function
		numbered_list_display "${var1_available}" "${var2_list}"

		# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
		folders_chosen="${files_to_use}"

		# Cleaning the contents of the variables below
		unset files_to_use
	fi

	echo
	echo -e "These are the entered GFEAT folders to be interrogated:\n"

	if [ "$folders_chosen" = all ] || [ "$folders_chosen" = ALL ]
	then
		# Variable to assign cope numbering to "all"
		folders_chosen_all=yes

		folders_chosen=`ls -xd ${FULLPATH}/${analysis_level}/*.gfeat/cope1.feat | sed "s!${FULLPATH}/${analysis_level}/!!" | sed "s/.gfeat//" | sed "s!/cope1.feat!!"`

		for folder in ${folders_chosen}
		do
			echo ${folder}
		done
	else
		# Variable to assign cope numbering to "all"
		folders_chosen_all=no

		# Testing if the folders entered by the user are valid
		echo
		echo -e "Testing the if the folders entered exists"

		for folder in ${folders_chosen}
		do
			foldercheck=${FULLPATH}/${analysis_level}/${folder}.gfeat
			checkfoldexist
		done
	fi

	echo -e "\n"
	echo -en "Is this correct?(y/n) "
	read yesno

	case ${yesno} in
	Y | y)
		# Putting absolute path for the chosen folders
		for folder in ${folders_chosen}
		do
			folder_fullpath="${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat"

			# New variable to hold the folders chosen with their respective absolute path
			FOLDERS_INTERROGATE="${FOLDERS_INTERROGATE} ${folder_fullpath} "
		done

		# Variable to hold the name of the GFEAT folders chosen without the fullpath
		FOLDERS_CHOSEN=${folders_chosen}

		break ;;
	N | n)
		echo -e "\n"
		echo -en "Please correct the FEAT folders to be interrogated "

		sleep 2 ;;
	*)
		echo -en "No valid option chosen "
		sleep 2 ;;
	esac
done
}

function interrogate_feat {
# Loop so the user can choose the COPE files to be used
echo
echo -e "You must now choose the \"cope\" files to be interrogated"
echo -e "The associated statistical images will be chosen automatically based you choice, i.e. pe, varcope, tstat,zstat,thresh_zstat\n"

# Creating a text file to hold the information entered within the "/tmp" folder - in case of any error in the script there will not be any temporary "trash" files
cd /tmp

# Removing temporary folders and files created, just in case they were not deleted properly by a previously ran script
rm -r ${temp_folder} 2> /dev/null

# Creating a folder to hold all files created by this script
mkdir -p ${temp_folder}/featquery_interrogate 2> /dev/null

echo -e "\t ** THIS FILE HOLDS THE INFORMATION FOR FEATQUERY SCRIPT **\n" > ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
echo -e "\tCreated in `date +"%Y%b%d, %H:%M %p"`\n\n" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt

# Creating a variable to number each FEAT folder to be interrogated - this has to stay out of the "folder in ${FOLDERS_INTERROGATE}" loop so it can be processed correctly
feat_folder_number=1

for folder in ${FOLDERS_INTERROGATE}
do
	while [ 1 ]
	do
		# Removing the full path from the "folder" variable
		folder_nopath=`echo ${folder} | sed "s!${FULLPATH}/${analysis_level}/!!" | sed "s/.gfeat//" | sed "s!/cope1.feat!!"`

		echo
		echo
		echo -e "##### FEAT folder: ${folder_nopath} #####"
		echo -e "These are the cope files found in this FEAT folder:\n"

		# Using two "ls" commands so the cope files are in correct numerical order according to the number of digits in the copeXX file name
		ls -x ${folder}/stats/cope?.nii.gz 2> /dev/null | sed "s!${folder}/stats/!!" | sed "s/.nii.gz//"
		ls -x ${folder}/stats/cope??.nii.gz 2> /dev/null | sed "s!${folder}/stats/!!" | sed "s/.nii.gz//"

		echo
		echo -en "Enter here the cope files to be used using ONLY their respective NUMBERS (if you want ALL of them, just enter \"all\"): "
		read cope_numbers_chosen

		echo
		echo -e "These are the entered cope files:\n"

		if [ "$cope_numbers_chosen" = all ] || [ "$cope_numbers_chosen" = ALL ]
		then
			# Variable to assign cope numbering to "all"
			cope_all=yes

			cope_number=1

			for item in `ls ${folder}/stats/cope*.nii.gz`
			do
				echo cope${cope_number}

				cope_number=$[ $cope_number + 1 ]
			done
		else
			# Variable to assign cope numbering to "all"
			cope_all=no

			for cope_number in ${cope_numbers_chosen}
			do
				echo cope${cope_number}
			done
		fi

		echo -e "\n"
		echo -en "Is this correct?(y/n) "
		read yesno

		case ${yesno} in
		Y | y)
			# Creating a variable to count how many cope files were chosen
			cope_files_count=0

			if [ ${cope_all} = yes ]
			then
				cope_number=1

				# Putting absolute path for the chosen folders, and adding all other statistics available in the cope1.feat folder
				for item in `ls ${folder}/stats/cope*.nii.gz`
				do
					cope_path="stats/cope${cope_number}"
					pe_path="stats/pe${cope_number}"
					varcope_path="stats/varcope${cope_number}"
					tstat_path="stats/tstat${cope_number}"
					zstat_path="stats/zstat${cope_number}"
					thresh_zstat_path="thresh_zstat${cope_number}"

					# New variables to hold the folders chosen with their respective path
					cope_files="${cope_files} ${cope_path} "
					pe_files="${pe_files} ${pe_path} "
					varcope_files="${varcope_files} ${varcope_path} "
					tstat_files="${tstat_files} ${tstat_path} "
					zstat_files="${zstat_files} ${zstat_path} "
					thresh_zstat_files="${thresh_zstat_files} ${thresh_zstat_path} "

					# Adding a unit to the number of cope files to be used
					cope_files_count=$[ $cope_files_count + 1 ]

					# Adding a unit to the count of cope files for variables naming above
					cope_number=$[ $cope_number + 1 ]
				done
			elif [ ${cope_all} = no ]
			then
				cope_number=1

				# Putting absolute path for the chosen folders, and adding all other statistics available in the cope1.feat folder
				for cope_number in ${cope_numbers_chosen}
				do
					cope_path="stats/cope${cope_number}"
					pe_path="stats/pe${cope_number}"
					varcope_path="stats/varcope${cope_number}"
					tstat_path="stats/tstat${cope_number}"
					zstat_path="stats/zstat${cope_number}"
					thresh_zstat_path="thresh_zstat${cope_number}"

					# New variables to hold the folders chosen with their respective path
					cope_files="${cope_files} ${cope_path} "
					pe_files="${pe_files} ${pe_path} "
					varcope_files="${varcope_files} ${varcope_path} "
					tstat_files="${tstat_files} ${tstat_path} "
					zstat_files="${zstat_files} ${zstat_path} "
					thresh_zstat_files="${thresh_zstat_files} ${thresh_zstat_path} "

					# Adding a unit to the number of cope files to be used
					cope_files_count=$[ $cope_files_count + 1 ]

					# Adding a unit to the count of cope files for variables naming above
					cope_number=$[ $cope_number + 1 ]
				done
			fi

			# Multiplying the total of cope files to be processed by the amount of the other statistic files (pe, varcope, tstat, zstat, thresh_zstat)
			cope_files_count=$[ $cope_files_count * 6 ]

			##### After collecting the cope files, this will put the info for each subject in the text file created above ####
			cd /tmp

			# This is to add trailing zeros to this number, so instead of "2" you have "002" for example
			feat_folder_number=`printf "%03d" ${feat_folder_number}`

			echo -e "Information entered for ${folder}\n" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "feat_folder_ID_${feat_folder_number}=${folder}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "cope_files_count_${feat_folder_number}=${cope_files_count}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "cope_files_list_${feat_folder_number}=${cope_files}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "pe_files_list_${feat_folder_number}=${pe_files}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "varcope_files_list_${feat_folder_number}=${varcope_files}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "tstat_files_list_${feat_folder_number}=${tstat_files}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "zstat_files_list_${feat_folder_number}=${zstat_files}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo -e "thresh_zstat_files_list_${feat_folder_number}=${thresh_zstat_files}" >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt
			echo >> ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt

			# Adding a unit to the variable feat_folder_number for the next item to be processed by the loop above
			# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
			feat_folder_number=$[10#${feat_folder_number}+1]

			# Cleaning variables content for the next loop
			unset cope_files
			unset pe_files
			unset varcope_files
			unset tstat_files
			unset zstat_files
			unset thresh_zstat_files

			break ;;
		N | n)
			echo -e "Please correct the cope files to be used "
			sleep 2 ;;
		*)
			echo -en "No valid option chosen " ;;
		esac
	done
done

# Creating a variable to number each FEAT folder to be interrogated - this has to stay out of the "folder in ${FOLDERS_INTERROGATE}" loop so it can be processed correctly
feat_folder_number02=1

for folder in ${FOLDERS_CHOSEN}
do
	# This creates an empty file
	touch ${temp_folder}/folders_featquery_analysis_${folder}.txt

	# This is to add trailing zeros to this number, so instead of "2" you have "002" for example
	feat_folder_number02=`printf "%03d" ${feat_folder_number02}`

	# VARIABLES TO BE USED FOR FEATQUERY COMMAND LINE. Has to use double quotes for sed to expand the variables within it
	feat_folder=`grep feat_folder_ID_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^feat_folder_ID_${feat_folder_number02}=//p"`

	cope_files_count=`grep cope_files_count_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^cope_files_count_${feat_folder_number02}=//p"`

	cope_files_list=`grep cope_files_list_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^cope_files_list_${feat_folder_number02}=//p"`

	pe_files_list=`grep pe_files_list_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^pe_files_list_${feat_folder_number02}=//p"`

	varcope_files_list=`grep varcope_files_list_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^varcope_files_list_${feat_folder_number02}=//p"`

	tstat_files_list=`grep tstat_files_list_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^tstat_files_list_${feat_folder_number02}=//p"`

	zstat_files_list=`grep zstat_files_list_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^zstat_files_list_${feat_folder_number02}=//p"`

	thresh_zstat_files_list=`grep thresh_zstat_files_list_${feat_folder_number02} ${temp_folder}/featquery_interrogate/FEATQUERY_holding_file_temp.txt | sed -n "s/^thresh_zstat_files_list_${feat_folder_number02}=//p"`

	##### Creating a LOG file with the "asl_file" command used for later QA if needed #####
	echo "OS name and version: ${os_nameandversion}; Command: featquery; FSL `cat $FSLDIR/etc/fslversion`; Date and time: `current_date_time 2`" > ${FULLPATH}/${analysis_level}/LOGFILE_featquery-ROI-inquiry_${folder}.txt

	echo -e "Command featquery to extract ROI data from FEAT results" >> ${FULLPATH}/${analysis_level}/LOGFILE_featquery-ROI-inquiry_${folder}.txt
	###############################################################

	# Adding lines to the text file to be used with PPSS. Will use a loop to add a line for each ROI mask selected by the user
	for mask in ${MASKS_TO_USE}
	do
		####### Command to run FEATQUERY and output parameter estimates ##########
		echo "featquery 1 ${feat_folder} ${cope_files_count} ${pe_files_list} ${cope_files_list} ${varcope_files_list} ${tstat_files_list} ${zstat_files_list} ${thresh_zstat_files_list} featquery_PARAMETER_ESTIMATE_${mask} -s ${masks_path}/${mask}" >> ${temp_folder}/folders_featquery_analysis_${folder}.txt

		####### Command to run FEATQUERY and output parameter estimates converted into percent ##########
		echo "featquery 1 ${feat_folder} ${cope_files_count} ${pe_files_list} ${cope_files_list} ${varcope_files_list} ${tstat_files_list} ${zstat_files_list} ${thresh_zstat_files_list} featquery_PERCENT_${mask} -p -s ${masks_path}/${mask}" >> ${temp_folder}/folders_featquery_analysis_${folder}.txt

		##### Creating a LOG file with the "asl_file" command used for later QA if needed #####
		echo -e "\nfeatquery 1 ${feat_folder} ${cope_files_count} ${pe_files_list} ${cope_files_list} ${varcope_files_list} ${tstat_files_list} ${zstat_files_list} ${thresh_zstat_files_list} featquery_PARAMETER_ESTIMATE_${mask} -s ${masks_path}/${mask}\nfeatquery 1 ${feat_folder} ${cope_files_count} ${pe_files_list} ${cope_files_list} ${varcope_files_list} ${tstat_files_list} ${zstat_files_list} ${thresh_zstat_files_list} featquery_PERCENT_${mask} -p -s ${masks_path}/${mask}" >> ${FULLPATH}/${analysis_level}/LOGFILE_featquery-ROI-inquiry_${folder}.txt
		###############################################################
	done

	# Adding a unit to the variable subj_number for the next subject to be processed by the loop above
	# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
	feat_folder_number02=$[10#${feat_folder_number02}+1]
done

# Generating the file holding all the commands to be ran using PPSS
for folder in ${FOLDERS_CHOSEN}
do
	cat ${temp_folder}/folders_featquery_analysis_${folder}.txt >> ${temp_folder}/${ppss_command_file}
done

# Calling the function "parallel_processing_ppss" (functionslibr_FSL) to run FEATquery command. Note 4 parameters: 1) path to the folder holding the temporary files for this script; 2) the name of the files holding the commands for PPSS to run; 3) parameter to indicate that the PPSS log files should be deleted by the function 4) list of unique identifiers for differentiating commands, e.g. a list of subjects. NOT USING THE 4th PARAMETER, SO ALL SUBJECT'S FILES ARE PROCESSED IN A ROW, INSTEAD OF ON A SUBJECT-BY-SUBJECT BASIS (FASTER AND OPTIMIZED USE OF PPSS)
parallel_processing_ppss ${temp_folder} ${ppss_command_file} ppss_function

# Removing all temporary fsf templates and their temp folder within "/tmp" that might be present from previously aborted processing
rm -rf ${temp_folder} 2> /dev/null
}

function extract_featquery_output {
# This function will remove statistics of interest from FEATQUERY output and save it into a text file exportable to a spreadsheet

echo
echo -e "##########################################################################################"
echo -e "##### Extracting FEATQUERY output into a text file to be imported into a spreadsheet #####"
echo -e "##########################################################################################"

# Checking if a folder to hold the text files produced by this function is available
while [ 1 ]
do
	if [ -d ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS ]
	then
		echo -e " *** ATTENTION! Procceding will delete any previous files stored within this folder: ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS ***"
		echo -e "You should check first if there are any files you want to keep before resuming\n"

		echo -en "Do you want to continue?(y/n) "
		read yesno

		if [ "$yesno" = y ] || [ "$yesno" = Y ]
		then
			echo -n
		else
			echo "Going back to main menu "
			sleep 3
			exit
		fi

		break
	else
		echo
		echo -e "There is not FEATQUERY_RESULTS folder within \"${analysis_level}\""

		echo
		echo -en "Do you want to create it and continue (if not, will abort)?(y/n) "
		read yesno

		case $yesno in
		y | Y)
			mkdir ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS

			echo
			echo -en "Folder created - continuing "
			sleep 2

			break ;;
		n | N)
			echo
			echo -en "Aborting the program and going back to the PROCESSING menu "
			sleep 2

			exit ;;
		*)
			echo
			echo -e "No valid option chosen\n"
			sleep 3 ;;
		esac
	fi
done

# Creating a text file to hold the information entered within the "/tmp" folder - in case of any error in the script there will not be any temporary "trash" files
cd /tmp

# Removing temporary folders and files created, just in case they were not deleted properly by a previously ran script
rm -r ${temp_folder}/featquery_interrogate 2> /dev/null

# Creating a folder to hold all files created by this script
mkdir -p ${temp_folder}/featquery_interrogate 2> /dev/null

echo -e "\t ** THIS FILE HOLDS THE INFORMATION FOR FEATQUERY SCRIPT **\n" > ${temp_folder}/featquery_interrogate/featquery_extract_output.txt
echo -e "\tCreated in `date +"%Y%b%d, %H:%M %p"`\n\n" >> ${temp_folder}/featquery_interrogate/featquery_extract_output.txt

# Loop to collect from user the FEATQUERY folders to be processed
echo -e "\n"
echo -e "Analysis level: ${analysis_level}"

# Creating a variable to number each FEAT folder to be interrogated - this has to stay out of the "folder in ${FOLDERS_INTERROGATE}" loop so it can be processed correctly
folder_gfeat_number=1
folder_featquery_number=1

for folder in ${folders_chosen}
do
	echo
	echo -e "##### GFEAT folder: ${folder} #####"
	echo -e "FEATQUERY folder(s) in this GFEAT folder:\n"

	# Listing the FEATQUERY folders according to their output format (parameter estimate or percent)
	folders_list1=`ls -d1 ${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/featquery_PARAMETER_ESTIMATE_* 2> /dev/null | sed "s!${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/!!"`
	folders_list2=`ls -d1 ${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/featquery_PERCENT_* 2> /dev/null | sed "s!${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/!!"`

	# This will check if there are folders listed, and if not will let the user know
	if [ -z "$folders_list1" ] && [ -z "$folders_list2" ]
	then
		echo -e "No FEATQUERY folders were found for this GFEAT folder\n"
	else
		for item in `echo $folders_list1`
		do
			echo $item
		done

		for item in `echo $folders_list2`
		do
			echo $item
		done
	fi

	while [ 1 ]
	do
		echo
		echo -en "Please choose the FEATQUERY folders to be processed from the list above, followed by a space (if you want ALL of them, just enter \"all\"; if you want none, enter \"none\"): "
		read folders_featquery_choosen

############ Add numbered choice display here ######################

		echo
		echo -e "These are the entered FEATQUERY folders to be processed:\n"

		if [ "$folders_featquery_choosen" = all ] || [ "$folders_featquery_choosen" = ALL ]
		then
			# Variable to assign cope numbering to "all"
			folders_featquery_all=yes

			folders_featquery_choosen=`ls -d ${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/featquery_PARAMETER_ESTIMATE_*  | sed "s!${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/!!";ls -d ${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/featquery_PERCENT_*  | sed "s!${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat/!!"`

			for item in ${folders_featquery_choosen}
			do
				echo ${item}
			done
		elif [ "$folders_featquery_choosen" = none ] || [ "$folders_featquery_choosen" = NONE ]
		then
			# Variable to assign cope numbering to "all"
			folders_featquery_all=none

			echo -e "*** No FEATQUERY folder will be processed for this GFEAT folder: ${folder} ***"
		else
			# Variable to assign cope numbering to "all"
			folders_featquery_all=no

			for item in ${folders_featquery_choosen}
			do
				echo ${item}
			done
		fi

		echo
		echo -en "Is this correct?(y/n) "
		read yesno

		case ${yesno} in
		Y | y)
			# This will separate the subjects that did not have FEATQUERY folders processed into a variable
			if [ "$folders_featquery_all" = none ] || [ "$folders_featquery_all" = NONE ]
			then
				# Adding the full path for the GFEAT folder into a variable
				folder_fullpath=${FULLPATH}/${analysis_level}/${folder}.gfeat/cope1.feat

				# Removing the subject without processed files from the variable "FOLDERS_INTERROGATE"
				FOLDERS_INTERROGATE=${FOLDERS_INTERROGATE/$folder_fullpath/}

				FOLDERS_CHOSEN=${FOLDERS_CHOSEN/$folder/}

				# Adding the subject without processed files to the variable "SUBJS_NOT_PROCESSED"
				SUBJS_NOT_PROCESSED="${SUBJS_NOT_PROCESSED} ${folder}"
			else
				folders_featquery_process=${folders_featquery_choosen}

				##### After collecting info above, this will put the info for each subject in the text file created above ####
				cd /tmp

				# This is to add trailing zeros to this number, so instead of "2" you have "002" for example
				folder_gfeat_number=`printf "%03d" ${folder_gfeat_number}`

				# This has to stay out of the loop below, so it won't be repeated
				echo -e "Information entered for ${folder}\n" >> ${temp_folder}/featquery_interrogate/featquery_extract_output.txt

				# This is to add trailing zeros to this number, so instead of "2" you have "002" for example
				folder_featquery_number=`printf "%03d" ${folder_featquery_number}`

				echo -e "folder_featquery_process_${folder_featquery_number}="${folders_featquery_process}"" >> ${temp_folder}/featquery_interrogate/featquery_extract_output.txt

				# Adding a unit to the variable folder_featquery_number for the next item to be processed by the loop above
				# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
				folder_featquery_number=$[10#${folder_featquery_number}+1]

				# Has to stay out of the loop so it's entered only at the end of the text block
				echo >> ${temp_folder}/featquery_interrogate/featquery_extract_output.txt

				# Adding a unit to the variable feat_folder_number for the next item to be processed by the loop above
				# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
				folder_gfeat_number=$[10#${folder_gfeat_number}+1]
			fi

			break ;;
		N | n)
			echo -e "Please correct the FEATQUERY folders to be processed\n"
			sleep 2 ;;
		*)
			echo -en "No valid option chosen " ;;
		esac
	done
done

# Entering the /tmp directory just in case any errors occur, it will not mess up the filesystem
cd /tmp

# Adding each FEAT folder characteristics to variables from the text file created above

# Creating a variable to number each FEAT folder to be interrogated - this has to stay out of the "folder in ${FOLDERS_INTERROGATE}" loop so it can be processed correctly
folder_featquery_number02=1

for folder in ${FOLDERS_INTERROGATE}
do
	# Removing the full path from the "folder" variable
	folder_nopath=`echo ${folder} | sed "s!${FULLPATH}/${analysis_level}/!!" | sed "s/.gfeat//" | sed "s!/cope1.feat!!"`

	# Giving feedback to user
	echo
	echo -en "Collecting FEATQUERY output data for GFEAt folder \"${folder_nopath}\" "

	# This is to add trailing zeros to this number, so instead of "2" you have "002" for example
	folder_featquery_number02=`printf "%03d" ${folder_featquery_number02}`

	folder_featquery_process=`grep folder_featquery_process_${folder_featquery_number02} ${temp_folder}/featquery_interrogate/featquery_extract_output.txt | sed -n "s/^folder_featquery_process_${folder_featquery_number02}=//p"`

	for folder_featquery_process_text in ${folder_featquery_process}
	do
		# Making list of all stats present in the "report.txt." file
		stats_files_report=`cat ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $2}'`

		#### Retrieving the FEATQUERY output info ####
		for item in ${stats_files_report}
		do
			# Removing the "stats/" from the statistics file path
			item_nopath=`echo ${item} | sed 's!stats/!!'`

			# Removing the "featquery_" from the "folder_featquery_process_text" variable to put it into the text file
			PE_percent_ROI=`echo ${folder_featquery_process_text} | sed 's!featquery_!!'`

			# Collecting the information into variables
			voxelsnonzero=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $3}'`
			min=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $4}'`
			tenpercent=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $5}'`
			mean=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $6}'`
			median=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $7}'`
			ninetypercent=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $8}'`
			max=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $9}'`
			stddev=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $10}'`
			coord_mni_X=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $14}'`
			coord_mni_Y=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $15}'`
			coord_mni_Z=`grep -w ${item} ${folder}/${folder_featquery_process_text}/report.txt | awk '{print $16}'`

			# Adding the info from variables into the unique text file created below
			echo ${folder_nopath} ${PE_percent_ROI} ${item_nopath} ${voxelsnonzero} ${min} ${mean} ${median} ${max} ${tenpercent} ${ninetypercent} ${stddev} ${coord_mni_X} ${coord_mni_Y} ${coord_mni_Z} >> ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${folder_nopath}_${folder_featquery_process_text}_${item_nopath}.txt
		done
	done

	# Adding a unit to the variable subj_number for the next subject to be processed by the loop above
	# Note the use of "10#" - this is because numbers like 008 or 009 are interpreted as octal by bash during arithmetic operations. So by using "10#" you tell bash that these number are base 10
	folder_featquery_number02=$[10#${folder_featquery_number02}+1]

	# Giving feedback to user
	echo
	echo -e "Done processing GFEAt folder \"${folder_nopath}\"\n"
done

# Moving the files to respective folders according to the stats type
# Checking if the folders were already created
folders_output_files="pe_files cope_files varcope_files tstat_files zstat_files thresh_zstat_files"

for folder_output in ${folders_output_files}
do
	if [ -d ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${folder_output} ]
	then
		echo -en
	else
		# Creating the folders to hold the files
		mkdir ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${folder_output}
	fi
done

# Moving the files - Note that the thresh_zstat files have to be moved first since if you try to move the zstat files first it will include both thresh_zstat and zstat file due to its similar name

# Creating a loop for the "mv" command, since if there are too many files it will give out an error "Argument list too long". With a loop, the "mv" command will be issue for each file individually - this takes more time but avoids that error

echo -en "Moving the FEATQUERY output text files into their respectives folders "

# Entering into the "${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/" folder so the "ls" command doesn't run into the "argument list too long" error
cd ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/

for file in `ls *_thresh_zstat*.txt`
do
	mv ${file} thresh_zstat_files/
done

for file in `ls *_zstat*.txt`
do
	mv ${file} zstat_files/
done

for file in `ls *_tstat*.txt`
do
	mv ${file} tstat_files/
done

for file in `ls *_pe*.txt`
do
	mv ${file} pe_files/
done

for file in `ls *_cope*.txt`
do
	mv ${file} cope_files/
done

for file in `ls *_varcope*.txt`
do
	mv ${file} varcope_files/
done

echo
echo -e "Finished collecting data for all GFEAT folders selected:\n\n${FOLDERS_CHOSEN}\n"

# Checking if there were subjects not processed, and let the user know the result
if [ -z $SUBJS_NOT_PROCESSED ]
then
	echo -n
else
	echo -e "These subjects were not processed due to no FEATQUERY folders found or chosen :\n${SUBJS_NOT_PROCESSED}\n"
fi

echo -en "Press anykey to continue "
read anykey
}

function files_group_PE-percent_ROI {
# This function will further triage the generated text files above according to the group, PE or percent, and ROI

# Creating a text file to hold the information entered within the "/tmp" folder - in case of any error in the script there will not be any temporary "trash" files
cd /tmp

echo
echo -e "This will triage the FEATQUERY output text files according to subjects group, contrasts, if files are parameter estimates or percent, and for each ROI"

while [ 1 ]
do
	echo -e "\n"
	echo -e "Please enter a unique paired-identifier separated by a \"=\" sign for each subject's group text files, and each paired-identifier is followed by space"
	echo -e "Where the first word is a group identifier CREATED by you NOW to name the files generate by this script, and the second is the identifier ALREADY present in the FEATQUERY output text file names. You can also use wildcards like \"?\" to substitute characters"
	echo -e "\n*** IT IS VERY IMPORTANT THAT THE 2ND IDENTIFIER IS UNIQUE FOR EACH GROUP, OTHERWISE THE OUTPUT FILES WILL HAVE DATA FROM OTHER GROUPS IN IT ***\n"
	echo -e "An example would be \"controls=N pain=P\", or \"controls=N0??_painlock pain=P0??_painlock\""
	echo -e "You may need to look at ther FEATQUERY output text file names to figure this second unique identifier\n"

	echo -en "Enter identifier here: "
	read filename_group_ID

	#NEED TO DETERMINE A GROUP IDENTIFIER TO NAME THE OUTPUT TEXT FILE FROM THIS FUNCTION. NEEDS TO ASSOCIATE THE group_ID TO THIS

	echo
	echo -en "Enter the stats type you want - \"1\" for PARAMETER ESTIMATE; \"2\" for PERCENT; \"3\" for both: "
	read PE_percent

	if [ $PE_percent = 1 ]
	then
		PE_percent=PARAMETER_ESTIMATE
	elif [ $PE_percent = 2 ]
	then
		PE_percent=PERCENT
	elif [ $PE_percent = 3 ]
	then
		PE_percent="PARAMETER_ESTIMATE PERCENT"
	fi

	# Gathering info on which contrasts to be used in the triage
	echo
	echo -e "You may choose to collect data on all contrasts available (all pe, cope, varcope, tstat, zstat, thresh files)"
	echo -e "or just a few of those (look in the folder \"${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS\" to check which are available)\n"

	echo -en "Please if you want to collect data on: 1. all contrasts; or 2. choose which ones: "
	read contrasts_all_choose

	# Checking user option on contrasts to be collected
	if [ ${contrasts_all_choose} = 1 ]
	then
		contrasts_to_collect=all
	else
		echo
		echo -en "Please enter here the NUMBER of each specific contrast(s) you wish to have data collected of: "
		read contrasts_to_collect
	fi

	# Checking if there is a path to the masks folder
	if [ -z "${masks_path}" ] # Checking if this variable already has content
	then
		echo
		echo -en "Please enter the FULL PATH for the ROI masks to be used in FEATQUERY: "
		read masks_path
	else
		echo
		echo -e "Path to masks folder that will be used: ${masks_path}"
	fi

	echo
	echo -e "Enter the ROIs to be processed:\n"

	# This command lists only the masks file without the ".nii.gz" and also number them. The grep command used here selects all the non-directories listed using the invert-matching flag (-v)
	ls -l ${masks_path}/*.nii.gz | sed 's!'${masks_path}'/!!' | grep -v ^d | awk '{print $9}' | sed "s/.nii.gz//" | sed '=' | sed 'N; s/\n/) /'

	echo
	echo -en "Enter your option here  - choose either their number followed by a space or \"all\": "
	read masks_to_use_chosen

	if [ "$masks_to_use_chosen" = all ] || [ "$masks_to_use_chosen" = ALL ]
	then
		# Variable to assign masks numbering to "all"
		masks_all=yes

		masks_to_use=`ls -l ${masks_path}/*.nii.gz | sed 's!'${masks_path}'/!!' | grep -v ^d | awk '{print $9}' | sed "s/.nii.gz//"`
	else
		# Variable to assign masks numbering to "all"
		masks_all=no

		# Listing all masks available and gathering their numbering
		masks_list_numbered=`ls -l ${masks_path}/*.nii.gz | sed 's!'${masks_path}'/!!' | grep -v ^d | awk '{print $9}' | sed "s/.nii.gz//" | sed '=' | sed 'N; s/\n/=/'`

		# Loop to associate each number chosen by user to the corresponding mask listed
		for mask_number in ${masks_to_use_chosen} # This will loop through only the masks chosen by the user
		do
			# Loop to go through each ROI
			for item in ${masks_list_numbered} # This will show all masks available in the masks folder
			do
				# This command will gather into a variable all masks numbers by: 1. listing all masks available one by one (echo command); then 2. will only show the masks chosen by the user as the 1st sed command triages out all but the ones that match the number of the mask chosen by the user; and 3. cleaning their numbering (e.g. 1=) for presentation to the user (2nd sed command)
				masks_numbered=`echo $item | sed -n "/^${mask_number}=/p" | sed "s/${mask_number}=//"`

				masks_to_use="${masks_to_use} ${masks_numbered}"
			done
		done
	fi

	# Showing the user the info entered and asking if they are correct
	echo
	echo -e "##### These are the entered info: #####\n"

	echo -e "Subject group identifier(s) = ${filename_group_ID}"
	echo -e "Stats type(s) = ${PE_percent}"
	echo -e "Contrasts NUMBER(s) to be collected: ${contrasts_to_collect}"
	echo -e "ROI to be used = \n"

	for item in ${masks_to_use}
	do
		echo -e "\t$item"
	done

	echo
	echo -en "Is this correct?(y/n) "
	read yesno

	case $yesno in
	y | Y)
		break ;;
	n | N)
		echo
		echo -en "Please correct the info "

		# Clearing the path to the folder contain the mask images
		unset masks_path masks_to_use

		sleep 2 ;;
	*)
		echo
		echo -e "No valid option chosen - returning to previous menu\n"
		sleep 2
		clear ;;
	esac
done

echo
echo -en "Triaging all selected files..."

# Doing the triage
# folders_output_files="pe_files cope_files varcope_files tstat_files zstat_files thresh_zstat_files"
folders_output_files="cope_files"

# Checking if the use wants all contrasts to be collected or specific ones
if [ ${contrasts_to_collect} = all ]
then
	# Stats type loop
	for folder_output in ${folders_output_files}
	do
		# Extracting the file type into a variable
		file_type=`echo ${folder_output} | awk -F_ '{print $1}'`

		# Subject group loop
		for group in ${filename_group_ID}
		do
			# Separating the filename and group IDs
			group_ID=`echo ${group} | sed 's/=/ /' | awk '{print $1}'`
			filename_ID=`echo ${group} | sed 's/=/ /' | awk '{print $2}'`

			# PE or percent loop
			for pe_percent in ${PE_percent}
			do
				# ROI masks loop
				for ROI_mask in ${masks_to_use}
				do
					# Adding the header info to each text file created here
					echo -e "\"GFEAT folder\" \"PE or percent_ROI\" \"stats type\" \"non-zero voxels within mask\" \"min\" \"mean\" \"median\" \"max\" \"10%\" \"90%\" \"Std Dev\" \"max image voxel within the Featquery mask - Coord MNI X\" \"same - Coord MNI Y\" \"same - Coord MNI Z\"" > ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${group_ID}_${pe_percent}_${folder_output}_${ROI_mask}.txt

					# Extracting first the single digit images, i.e. cope1, cope2, etc, followed by double-digit one, i.e. cope10, cope11, etc.
					cat ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${folder_output}/*${filename_ID}*${pe_percent}*${ROI_mask}*${file_type}?.txt >> ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${group_ID}_${pe_percent}_${folder_output}_${ROI_mask}.txt

					cat ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${folder_output}/*${filename_ID}*${pe_percent}*${ROI_mask}*${file_type}??.txt >> ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${group_ID}_${pe_percent}_${folder_output}_${ROI_mask}.txt
				done
			done
		done
	done
else
	# Stats type loop
	for folder_output in ${folders_output_files}
	do
		# Subject group loop
		for group in ${filename_group_ID}
		do
			# Separating the filename and group IDs
			group_ID=`echo ${group} | sed 's/=/ /' | awk '{print $1}'`
			filename_ID=`echo ${group} | sed 's/=/ /' | awk '{print $2}'`

			# PE or percent loop
			for pe_percent in ${PE_percent}
			do
				# ROI masks loop
				for ROI_mask in ${masks_to_use}
				do
					# Collecting data on the specific contrasts chosen by the user
					for contrast_number in ${contrasts_to_collect}
					do
						# Adding the header info to each text file created here
						echo -e "\"GFEAT folder\" \"PE or percent_ROI\" \"stats type\" \"non-zero voxels within mask\" \"min\" \"mean\" \"median\" \"max\" \"10%\" \"90%\" \"Std Dev\" \"max image voxel within the Featquery mask - Coord MNI X\" \"same - Coord MNI Y\" \"same - Coord MNI Z\"" > ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${group_ID}_${pe_percent}_${folder_output}_${ROI_mask}.txt

						cat ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${folder_output}/*${filename_ID}*${pe_percent}*${ROI_mask}*${contrast_number}.txt >> ${FULLPATH}/${analysis_level}/_FEATQUERY_RESULTS/${group_ID}_${pe_percent}_${folder_output}_${ROI_mask}.txt
					done
				done
			done
		done
	done
fi

echo -e "\n"
echo -en "Triaged all files. Press any key to continue to PROCESSING MENU "
read -n1 anykey
}

################ VARIABLES TO BE USED IN THIS SCRIPT #################
# Variable to hold the folder name for the template FEAT files
feat_templates_folder=feat_templates

# Variable for the folder within "/tmp" for temporary files
temp_folder=/tmp/ppss_tempdir_featquery

# Variable holding the location of the 1st_level fMRI analysis
analysis_folder=analysis_BOLD_stim-evoked/1stlevel

# Variable with the basename for the file holding the commands for PPSS processing
ppss_command_file=featquery_analysis_list.txt
######################################################################

###########################################################################
###############			MAIN MENU ROUTINE			###############
###########################################################################

######### Script Main menu - Informing the user what this script does and asking for input #########
clear

while [ 1 ]
do
	# Changing directory to /tmp in case the script commits some error - this will make any commands to be run within /tmp, preventing damage to the file system
	cd /tmp

	echo
	echo -e "This program will interrogate previously ran FEAT analysis to obtain statistics on user-defined ROIs"
	echo -e "It will use a tool called \"FEATQUERY\", part of the FSL package"
	echo -e "This program will generate its results within the original FEAT folder used as input"
	echo -e "It will also generate a text file with the main results that can be imported to a spreadsheet program\n"

	echo -e "Please choose from the options below:\n"
	echo -e "\ta) Run FEATQUERY interrogation followed by results export to text file and triage"
	echo -e "\tb) Export FEATQUERY results already processed and triage them according to subject group, PE/percent, and ROI"
	echo -e "\tc) Triage FEATQUERY results already exported according to subject group, PE/percent, and ROI only\n"

	echo -en "Enter option here: "
	read option

	case ${option} in
	a | A)
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "roi_featquery:Run FEATquery to obtain mean ROI statistics from a previously ran FEAT analysis" FSL "(interrogate_feat) featquery"

		# Asking user to enter the full path to the masks folder
		while [ 1 ]
		do
			echo -e "\n"
			echo -en "Please enter the FULL PATH for the ROI masks to be used in FEATQUERY: "
			read masks_path

			echo
			echo -e "ROI masks available are listed below:\n"

			# Listing only files and not directories with this command
			ls -l ${masks_path}/*.nii.gz | grep -v ^d | awk '{print $9}' | sed 's!'${masks_path}/'!!' | sed "s/.nii.gz//" | sed "=" | sed 'N; s/\n/) /'

			echo
			echo -en "Now enter the number corresponding to the ROI masks to be used, separated by a space (if you want ALL of them, just enter \"all\"): "
			read MASKS_TO_USE

			if [ -n "${MASKS_TO_USE}" ] # Checking if this variable is non-zero in length
			then
				echo
				echo -e "You entered the following masks:"

				if [ "$MASKS_TO_USE" = all ] || [ "$MASKS_TO_USE" = ALL ]
				then
					# Variable to assign cope numbering to "all"
					masks_all=yes

					MASKS_TO_USE=`ls -l ${masks_path}/*.nii.gz | grep -v ^d | awk '{print $9}' | sed 's!'${masks_path}/'!!' | sed "s/.nii.gz//"`

					echo

					for mask in ${MASKS_TO_USE}
					do
						echo ${mask}
					done
				else
					# Variable to assign cope numbering to "all"
					masks_all=no

					# Collecting the atlases available into a variable to be used in the function "numbered_list" (functionslibr_FSL)
					var1_available=`ls -l ${masks_path}/*.nii.gz | grep -v ^d | awk '{print $9}' | sed 's!'${masks_path}/'!!' | sed "s/.nii.gz//" | sed "=" | sed 'N; s/\n/=/'` # variable with all the files in a numbered list. Note that, since the output of "Atlasquery" has spaces, another sed command is used to transform them into underscore
					var2_list="${MASKS_TO_USE}" # The numbers chosen by the user corresponding to the files to be used

					# Calling the function "numbered_list_display" to present the atlases available in a numbered list to the user. Note the parameters to be passed on to the function
					numbered_list_display "${var1_available}" "${var2_list}"

					# Retrieving the results of the function above from the variable "files_to_use" into a variable to be used by the present script
					MASKS_TO_USE="${files_to_use}"

					# Cleaning the contents of the variables below
					unset files_to_use

					echo

					for mask in ${MASKS_TO_USE}
					do
						echo ${mask}
					done
				fi
			fi

			echo
			echo -en "Is this correct?(y/n) "
			read yesno

			case ${yesno} in
			Y | y)
				break ;;
			N | n)
				echo
				echo -en "Please correct the fullpath to masks and/or the masks to be used "

				# Cleaning contents of the below variables
				unset masks_path
				unset MASKS_TO_USE

				sleep 2 ;;
			*)
				echo -en "No valid option chosen " ;;
			esac
		done

		echo
		echo -e "\n\tDo you want interrogate the results of:\n"
		echo -e "\t\t1) Subject-level FEAT analysis or"
		echo -en "\t\t2) Group-level FEAT analysis? "
		read level_feat

		case $level_feat in
		1)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Interrogated at subject-level FEAT analysis"

			# This variable will determine that the "1st_level" analysis folder will be used
			analysis_level=analysis_BOLD_stim-evoked/2ndlevel

			# Calling the function "choose_feat_folders" to choose the FEAT folders
			choose_feat_folders

			# Calling the function "interrogate_feat" to interrogate the FEAT folder using FEATQUERY
			interrogate_feat

			# Giving the user the option to EXTRACT OUTPUT IN SEQUENCE
			echo
			echo -en "Do you want to extract the FEATQUERY output processed?(y/n) "
			read yesno

			if [ $yesno = y ]
			then
				# Calling the function "extract_featquery_output" to extract FEATQUERY output into a importable text file
				extract_featquery_output
			else
				echo -en "\nGoing back to the PROCESSING MENU "
				sleep 3

				break
			fi

			# Giving the user the option to TRIAGE OUTPUT IN SEQUENCE
			echo
			echo -en "Do you want to triage the FEATQUERY output exported?(y/n) "
			read yesno

			if [ $yesno = y ]
			then
				# Calling the function "files_group_PE-percent_ROI" to triage FEATQUERY output text files according to subjects group, if files are paramater estimates or percent, and for each ROI
				files_group_PE-percent_ROI

				break
			else
				echo -en "\nGoing back to the PROCESSING MENU "
				sleep 3

				break
			fi ;;
		2)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Interrogated at group-level FEAT analysis"

			# This variable will determine that the "2nd_level" analysis folder will be used
			analysis_level=analysis_BOLD_stim-evoked/3rdlevel

			# Calling the function "choose_feat_folders" to interrogate the FEAT folder using FEATQUERY
			choose_feat_folders

			# Calling the function "interrogate_feat" to interrogate the FEAT folder using FEATQUERY
			interrogate_feat

			# Giving the user the option to EXTRACT OUTPUT IN SEQUENCE
			echo
			echo -en "Do you want to extract the FEATQUERY output processed?(y/n) "
			read yesno

			if [ $yesno = y ]
			then
				# Calling the function "extract_featquery_output" to extract FEATQUERY output into a importable text file
				extract_featquery_output
			else
				echo -en "\nGoing back to the PROCESSING MENU "
				sleep 3

				break
			fi

			# Giving the user the option to TRIAGE OUTPUT IN SEQUENCE
			echo
			echo -en "Do you want to triage the FEATQUERY output exported?(y/n) "
			read yesno

			if [ $yesno = y ]
			then
				# Calling the function "files_group_PE-percent_ROI" to triage FEATQUERY output text files according to subjects group, if files are paramater estimates or percent, and for each ROI
				files_group_PE-percent_ROI

				break
			else
				echo -en "\nGoing back to the PROCESSING MENU "
				sleep 3

				break
			fi ;;
		*)
			echo
			echo -e "No valid option chosen - returning to previous menu\n"
			sleep 3
			clear ;;
		esac ;;

	b | B)
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "roi_featquery:Export FEATquery results already processed and triage them according to subject group, PE/percent, and ROI" none "none"

		echo
		echo -e "\n\tDo you want extract the FEATQUERY output of:\n"
		echo -e "\t\t1) Subject-level or"
		echo -en "\t\t2) Group-level? "
		read level_feat

		case $level_feat in
		1)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Extracted subject-level FEATquery results"

			# This variable will determine that the "1st_level" analysis folder will be used
			analysis_level=analysis_BOLD_stim-evoked/2ndlevel

			# Calling the function "choose_feat_folders" to interrogate the FEAT folder using FEATQUERY
			choose_feat_folders

			# Calling the function "extract_featquery_output" to extract FEATQUERY output into a importable text file
			extract_featquery_output

			# Giving the user the option to TRIAGE OUTPUT IN SEQUENCE
			echo
			echo -en "Do you want to triage the FEATQUERY output exported?(y/n) "
			read yesno

			if [ $yesno = y ]
			then
				# Calling the function "files_group_PE-percent_ROI" to triage FEATQUERY output text files according to subjects group, if files are paramater estimates or percent, and for each ROI
				files_group_PE-percent_ROI

				break
			else
				echo -en "\nGoing back to the PROCESSING MENU "
				sleep 3

				break
			fi ;;
		2)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Extracted group-level FEATquery results"

			# This variable will determine that the "2nd_level" analysis folder will be used
			analysis_level=analysis_BOLD_stim-evoked/3rdlevel

			# Calling the function "choose_feat_folders" to interrogate the FEAT folder using FEATQUERY
			choose_feat_folders

			# Calling the function "extract_featquery_output" to extract FEATQUERY output into a importable text file
			extract_featquery_output

			# Giving the user the option to TRIAGE OUTPUT IN SEQUENCE
			echo
			echo -en "Do you want to triage the FEATQUERY output exported?(y/n) "
			read yesno

			if [ $yesno = y ]
			then
				# Calling the function "files_group_PE-percent_ROI" to triage FEATQUERY output text files according to subjects group, if files are paramater estimates or percent, and for each ROI
				files_group_PE-percent_ROI

				break
			else
				echo -en "\nGoing back to the PROCESSING MENU "
				sleep 3

				break
			fi ;;
		*)
			echo
			echo -e "No valid option chosen - returning to previous menu\n"
			sleep 3
			clear ;;
		esac ;;

	c | C)
		# Creating a log file. STEP 1 of 2 = start call
		# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 4 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The calling script and its purposes (separated by a semicolon); 3. The analysis software type (FSL, Freesurfer) related to the script's use; 4. The tools used (e.g., fsl_motion_outliers, fslreorient2std, etc.)
		log_file_scripts_used start "roi_featquery:Triage FEATquery results already exported according to subject group, PE/percent, and ROI" none "none"

		echo
		echo -e "\n\tDo you want triage FEATQUERY ouput of:\n"

		echo -e "\t\t1) Subject-level or"
		echo -en "\t\t2) Group-level? "
		read level_feat

		case $level_feat in
		1)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Triaged subject-level FEATquery results"

			# This variable will determine that the "1st_level" analysis folder will be used
			analysis_level=analysis_BOLD_stim-evoked/2ndlevel

			# Calling the function "files_group_PE-percent_ROI" to triage FEATQUERY output text files according to subjects group, if files are paramater estimates or percent, and for each ROI
			files_group_PE-percent_ROI

			break ;;
		2)
			# Creating a log file. STEP 1.5 of 2 = midscript call
			# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output additional info for this script. It uses 2 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. The additional info
			log_file_scripts_used midscript "Triaged group-level FEATquery results"

			# This variable will determine that the "2nd_level" analysis folder will be used
			analysis_level=analysis_BOLD_stim-evoked/3rdlevel

			# Calling the function "files_group_PE-percent_ROI" to triage FEATQUERY output text files according to subjects group, if files are paramater estimates or percent, and for each ROI
			files_group_PE-percent_ROI

			break ;;
		*)
			echo
			echo -e "No valid option chosen - returning to previous menu\n"
			sleep 3
			clear ;;
		esac ;;

	*)
		echo -en "No valid option chosen "
		sleep 3 ;;
	esac
done

# Creating a log file. STEP 2 of 2 = finish call
# Calling the function "log_file_scripts_used" in "functionslibr_FSL" to output the characteristics of this script. It uses 1 parameters: 1. Flag to signal if this function is being called when the calling script starts or when it has finished; 2. List of subjects processed
log_file_scripts_used finish "${SUBJLIST}"

# Going to /tmp for safety in case script goes awry
cd /tmp